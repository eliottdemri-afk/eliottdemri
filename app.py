"""
API FastAPI - Optimisation Planning Hospitalier V3.0 FINALE
Avec algorithmes G√©n√©tique2 et RecuitSimul√©2 (version performante)
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import joblib
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
import os
import random
import copy
import math
from datetime import datetime, timedelta
from dataclasses import dataclass
from collections import defaultdict
import warnings
from sklearn.exceptions import DataConversionWarning

# Supprimer warnings sklearn
warnings.filterwarnings('ignore', category=UserWarning, module='sklearn')
warnings.filterwarnings('ignore', category=DataConversionWarning)

# ============================================================================
# INITIALISATION FASTAPI
# ============================================================================

app = FastAPI(title="API Optimisation Hospitali√®re V3", version="3.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================================
# VACANCES SCOLAIRES 2025-2026
# ============================================================================

VACANCES_SCOLAIRES = [
    (datetime(2025, 2, 8), datetime(2025, 2, 23)),   # Hiver
    (datetime(2025, 4, 5), datetime(2025, 4, 21)),   # Printemps
    (datetime(2025, 7, 5), datetime(2025, 9, 1)),    # √ât√©
    (datetime(2025, 10, 18), datetime(2025, 11, 3)), # Toussaint
    (datetime(2025, 12, 20), datetime(2026, 1, 5)),  # No√´l
    (datetime(2026, 2, 7), datetime(2026, 2, 22)),   # Hiver 2026
]

def est_vacances(date_jour: datetime) -> bool:
    """V√©rifie si une date est pendant les vacances scolaires"""
    return any(debut <= date_jour <= fin for debut, fin in VACANCES_SCOLAIRES)

# ============================================================================
# CHARGEMENT MOD√àLE ML
# ============================================================================

print("Chargement du mod√®le ML...")
try:
    model_path = os.path.join(os.path.dirname(__file__), "modele_duree.pkl")
    model_data = joblib.load(model_path)
    classifier = model_data["classifier"]
    regressors = model_data["regressors"]
    scalers = model_data["scalers"]
    feature_cols = model_data["feature_cols"]
    print(f"‚úÖ Mod√®le charg√© ({len(feature_cols)} features)")
except Exception as e:
    print(f"‚ùå Erreur mod√®le: {e}")
    classifier, regressors, scalers, feature_cols = None, None, None, None

# ============================================================================
# CHARGEMENT BDD (MAPPING CCAM ‚Üí SP√âCIALIT√â)
# ============================================================================

print("Chargement BDD CCAM...")
try:
    bdd_path = os.path.join(os.path.dirname(__file__), "bdd_traitee_1_classified.csv")
    df_bdd = pd.read_csv(bdd_path)
    
    CCAM_TO_SPE = {}
    for _, row in df_bdd.iterrows():
        acte = row["acte_classant"]
        if pd.notna(row["Classification"]):
            classification = str(row["Classification"])
            premiere_spe = classification.split(";")[0].strip()
            CCAM_TO_SPE[acte] = premiere_spe
    
    print(f"‚úÖ BDD charg√©e: {len(CCAM_TO_SPE)} codes CCAM mapp√©s")
except Exception as e:
    print(f"‚ùå Erreur BDD: {e}")
    CCAM_TO_SPE = {}

# ============================================================================
# üî• LISTE COMPL√àTE DES 2910 CODES CCAM AUTORIS√âS
# ============================================================================


LISTE_ACTES_AUTORISES = [
    "HMFC004","FCFA009","JDDB007","JGFE023","LFAA002","JCAE001","DELF005","FCCA001",
    "NHDA009","DEKA001","EBFA002","FCCA001","JJFC010","DELF005","HMFC004","JKFA027",
    "QZMA001","QZFA038","JKDC001","NEKA020","JCAE001","HHFA002","HFFC018","QEFA020",
    "JDFE001","JGFA005","QEGA004","JJFC003","JCAE001","JDFE001","JANE005","HMFC004",
    "NEKA009","JFFC001","JKDC001","JJFC006","HHCC007","JKFC002","NEKA020","JKDC001",
    "NEKA005","HHFA016","KDQA001","KCFA005","LFAA002","JGFE023","JCGE005","JDFE001",
    "LFFA002","MJFA013","LMMC002","GDFA008","EDFA007","JEMA023","HPPC002","FCPA001",
    "DELF005","JKFA015","JCPD001","JCGE006","JKFA022","MACA001","BAMA004","LFAA002",
    "JJFC010","JKFA022","GFFA029","LMMA004","FCPA001","JCGE006","JCFE003","QEFA020",
    "JDFE002","JANE005","JGFE023","BFGA427","JBMC001","HMFC004","HMFC004","ZCJC001",
    "NEKA011","HHFA008","LFAA002","GHFA001","MAFA004","GHFA001","JDDB007","JDDB007",
    "LDFA008","JANE005","DELF005","CBPA002","HMFC004","LMMC002","HNFA007","LAFA019",
    "QZFA036","NBCA008","JJFJ001","JLCA009","HHCA001","EBFA016","ZCJA004","LMMA004",
    "EGFA002","QZFA035","DELF014","HHQE005","NFKA007","LHMA011","LMSA002","HHEE001",
    "HMFC004","JDFE002","HCFA008","QEFA008","LMMC002","GFFC002","JCLE002","JCLE002",
    "HMFC004","JGFE023","NBCA007","HHFA016","GHFA001","HNFA007","FCFA009","FCFA009",
    "QEFA020","JGFE023","JANE002","JGFE365","HMFC004","NBCA006","JJJC001","MBCA005",
    "FAFA014","LDFA008","JKFA027","HHFA025","HMFC004","HMFC004","JCGE006","FCFA029",
    "NEKA020","JJFC010","JCPD001","HKPA007","MEKA008","JKFC001","DELF005","JDDB005",
    "QEFA012","HDFA002","QEFA008","QEMA004","JDFE001","DCMA001","HPPC003","JJFC010",
    "JDFE001","JKFC002","JKFC005","BFGA427","QBFA006","EZSA004","JCGE006","NCCA005",
    "HGCC031","FCFC005","FCFA009","KCFA008","HHFA016","HHFA025","MCPA013","JEFA003",
    "JCGE006","JDFE003","JGFE023","MJJA004","JDFE002","NEKA020","NFMC003","NJPA018",
    "JJFC010","MCCA005","JGFE023","JCLE002","QEKA001","LFFA002","PAGA009","HHFA016",
    "NBCA007","LMMC002","QZMA001","JAGF001","QEFA020","HFFC018","JDFE001","JKFA022",
    "NEKA020","JEFA002","MCCA005","JJFA005","LCJA003","HMFC004","HKPA001","FCFA009",
    "HFFC018","FCFA009","NCCA017","JGFE023","LFFA002","HHFA016","EZCA003","JCGE006",
    "DCMA001","HFFC001","QEFA019","QEFA008","PZMA004","FCPA001","JKDC001","NGPA002",
    "MEKA002","BAFA006","LMMC002","HPPC003","NBCA006","HGPC015","HGPC015","KCFA005",
    "MEMA012","JGFE023","JCAE001","LMMC002","NCPA010","JKFA027","EGFA003","HFFC018",
    "NFMC003","NFKA008","HHFA008","JANE005","JJFC010","JCGE006","JAFC005","JJPC003",
    "DELF005","NHDA008","ECCA003","MBCA005","JDFE001","JCLE002","JCAE001","NEKA014",
    "NEKA011","HGPA004","JDJE001","GHFA001","FCFA009","DELF005","LMMC015","KCFA005",
    "LFAA002","JKFC005","LDFA008","FCFA009","JGFC001","HFCC003","EBFA016","FCCA001",
    "DELF005","DEKA001","EBFA016","JKFA020","JGFA005","EGFA001","JGFE023","HMFC004",
    "JMMA002","JKFC001","LFFA002","JKFA024","LFAA001","HMLE002","MCCA008","JGFC001",
    "QEKA001","QEFA008","QEMA010","HKPA005","JDPE001","JCGE001","LFKA001","NEKA005",
    "JJFC003","FCFA009","KCFA005","QZMA001","KCFA005","JJFC006","JLDA002","JDFE003",
    "LHCA010","JANE005","NEFA001","HHFA004","DELF014","FCPA001","QEFA008","PZMA004",
    "EBAF010","MEKA006","JKFA028","NBCA010","JANE002","NJMA002","LMMA004","LBGA004",
    "QZFA036","LFFA002","PDFA001","JGFE023","DELF005","KCFA011","JCGE001","JJFC010",
    "HMFC004","NEKA005","DEKA002","JAFC008","LJCA002","HMFC004","NCCA016","HMFC004",
    "DELF005","GGPA001","HHFA027","HPPC002","HHFA016","GFFA009","JDFE003","HHFA025",
    "JKFC005","HJFA004","EDFA007","FCPA001","FCPA001","QEFA008","DELF014","EEAF006",
    "DELF005","HMFC004","JFFC002","JKFC005","JGFE023","HJFA004","EGFA002","HFFC002",
    "JLFA003","JCGE001","NCCA017","MEKA008","JDFE002","FCCA001","HHFA002","QEFA017",
    "DELF005","JANE002","PDFA001","AHCA020","BFGA427","JCLE002","DELF005","NBCA010",
    "GFFC005","JCLE002","HMFC004","LMMC002","KCFA008","GHFA001","KCFA005","JEFA002",
    "LDAA001","JGFE023","LHCA010","HMFC004","PAGA009","NEKA005","FCCA001","DELF005",
    "QEMA013","JDFE001","JKFC005","QZFA011","JJFC003","JJFC006","HKSD001","HPPC002",
    "HFFC018","FCCA001","JDFE001","JDFE001","QEFA017","JANE005","DCMA001","NFFA004",
    "JAFC001","JDFE001","GFFA009","HMFC004","MEKA009","JCAE001","NFFC004","HGPA004",
    "KCFA005","HFFA008","MBPA001","KCFA008","JANE002","KCFA008","JKFA032","JGFE023",
    "JGFE023","JDFE001","NEKA020","HHFA008","CBMA002","EEAF006","PZMA004","DELF005",
    "JGFE023","JKFC001","JFFC002","JKFC005","HHFA008","QEEB152","DELF005","JAFC019",
    "NFKA008","QEFA008","JHFA008","JDJE001","QEGA001","JDFE001","JANE002","JKFC005",
    "NCCA010","NBCA014","MCCA005","HPPC003","HHFA008","DELF007","HMFC004","JKFA022",
    "HMFC004","HHFA016","FAFA014","HMFC004","DELF005","NHMA002","HHFA025","QEFA008",
    "HPPC003","LMMA006","HMFC004","NEKA020","HHFA016","HFFC018","JGFC001","JANE005",
    "GGNC001","QEGA004","JANE005","JDFA023","NEKA020","JCNE003","ECNF002","NEKA020",
    "JGFE023","NEEA002","DELF005","NBCA003","HMFC004","NBCA010","QBFA007","HCFA008",
    "HLFC027","MCCA011","NEKA020","JDDB007","HHFA025","JGFE023","HJFA004","HMFC004",
    "NHMA002","HJFC031","PZMA004","EEAF006","FCPA001","HHFA025","JDFE001","JKFC002",
    "NEKA020","JGFE023","FCCA001","QZFA014","JGFE023","FCPA001","JCLE002","JDFE001",
    "NCCA012","JCGE001","NJCA001","JCGE001","NEKA020","DELF005","MCCA005","LMMA006",
    "NEKA020","KCFA008","JDDB007","KCFA005","KCFA005","LDFA008","JJFC010","NEEA002",
    "HHFA008","JKFC001","HHFA024","JMFA001","QZMA004","JKFA022","JCNE003","GFFC002",
    "JBNE004","JJFC006","NEKA020","JCPD001","NBCA005","HHFA016","MBCA011","JHQA002",
    "JHFA006","JGFC001","FCPA001","LDAA001","HMFC004","NCCA004","KCFA008","FCFA009",
    "KDQA001","HHFA016","JANE002","LFAA002","DELF005","QZJA011","NHDA011","HDFA008",
    "JKFC001","NFJA001","NEKA020","FCPA001","HPPC001","QEFA020","JDFE002","EEAF006",
    "LFAA002","QZJA011","LDFA008","FCCA001","JJFC003","JJFC003","NEKA020","JHFA013",
    "JKFC002","PAGA011","EEAF006","NZFA010","MCCB001","FCFA009","KDQA001","HKPA007",
    "NELA002","HMFC004","FAFA014","NDCA003","FCPA001","FCPA001","LHMA011","JJFC003",
    "HFFC002","JGFE023","JDFE001","HPNC001","LFAA002","GFFC005","QZMA001","NCCA016",
    "JCLE002","JCKE002","JCAE001","QEKA001","JANE002","JGFE023","JCPD001","JDFE001",
    "NEKA020","PDFA001","JCGE001","NDPA011","NEKA020","JCAE001","JHKA004","NEKA011",
    "MCCB004","KCFA008","JGFE023","PDFA001","HHFA025","JGFC001","QEFA008","DELF014",
    "NDPA011","FCCA001","FCPA001","EBFA016","HFFC002","JKFA028","LFFA002","HPPC003",
    "NEKA020","HMFC004","JGFE023","JCAE001","DELF005","KDQA001","KCFA008","HFMC001",
    "HPNC001","DCMA001","KCFA008","LMMC002","PZMA004","PAGA009","EBFA016","JGFE023",
    "JGFE023","NCCA004","JAFC019","MCCA005","QEFA008","FCPA001","LBGA004","JDFE002",
    "PZMA004","JKFA020","JCGE006","JDFE001","JGFE023","QAGA004","NEKA004","JKGD002",
    "NGFA001","JGFC001","HGPC015","NEKA020","QZJA011","FCPA001","JDFE001","DELF005",
    "HFCC003","JGFE023","GAMA016","MCCA005","LDFA008","NBCA010","HHFA008","FCFA009",
    "FAFA015","FCCA001","QEFA020","QEFA017","JGFE023","JANE002","JCGE001","HMFC004",
    "JGFC001","KDFA001","JCAE001","MEKA008","EJBA001","HAMA002","FCFA009","FCFA009",
    "HHFA024","GFFC002","DELF005","JLCA005","GBPA002","NFKA003","HPPC002","FCPA001",
    "DELF005","JJFJ001","HMFC004","EGFA003","NEKA020","NBCA004","HFFC018","QEFA020",
    "JKFC002","HHFA008","JAFC005","QEFA008","JGFA005","DEKA001","JDFE001","QEFA020",
    "JANE002","QBPA001","JDFE001","JCLE002","DHFA002","GFFC002","HHFA025","HMFC004",
    "JDFE001","JCAH001","JDDB007","EEAF006","HHFA016","HHFA002","JGFC001","NEKA020",
    "FCPA001","HKPA007","HFFC002","BAMA004","JCAE001","NFMC003","MCCA003","QZFA014",
    "LHCA010","HMFC004","QEFA008","NCCA013","QZFA036","JGFE023","QZFA036","JGFC001",
    "DELF005","HMFC004","HMFC004","GHFA001","FCFA009","HFMC001","KCFA008","HMFC004",
    "HMFC004","JGFE023","JCAH001","JMPA001","QEDA004","EDFA007","DELF007","PDFA002",
    "HFFC018","NDFA002","JGFE023","HHFA010","HMFC004","QEFA008","JCNE004","AHPA006",
    "DCJA001","HMFC004","JHAA003","JKFA022","LHMA011","MJCA012","DDAF008","GHFA001",
    "HFMC003","KCFA008","GHFA001","JJFA010","JEMA023","JJFC010","NCCA001","ZCJC001",
    "HMFC004","NEKA020","LHCA010","FCCA001","JDFE002","DELF005","NDFA002","NEKA011",
    "HGPA004","HFFC002","JGFE023","JKFC001","LHMA011","LMMA004","JCLE002","GHFA001",
    "LMMA004","JBFC001","JDNE001","JDFE002","PZMA004","HGPC015","JGFE023","JKFC002",
    "DELF005","HHFA016","JCLE001","HHFA016","JJFJ001","QBFA007","BFGA427","HGPC015",
    "JGFC001","JDFA025","HMFC004","FCFA009","KDQA001","QEFA008","GHFA001","DELF013",
    "JKFA008","JJFC010","HGPC015","FAFA014","JJFC010","HHFA010","EDCA005","DELF005",
    "JCGE005","JCLE002","LMMC002","QZFA011","PAGA009","JKFA020","HMFC004","JGFC001",
    "NEKA020","FCFA029","JGFE023","JDFE002","HHFA025","HGPC015","HPPC003","JDFE001",
    "JGFE023","DELF005","JCGE001","HMFC004","JCGE001","HMFC004","JGFE023","AHPC001",
    "NEKA020","LFFA002","AHPA009","QBFA007","LMMC003","ZCJC001","JANE002","JHFA008",
    "LMMC002","MBCA006","HMFC004","HPPC003","NCCA017","FCFA009","HLFC002","KCFA008",
    "KDQA001","HHFA016","EZMA001","FCPA001","LHMA011","NEKA005","LMMC015","JCLE002",
    "ZCJC001","FCCA001","FCCA001","HHFA008","GGNC001","JKFA015","GAMA016","JGFE023",
    "DDQH009","NFKA008","NEKA010","HMQJ002","JAFA032","JHFA019","LHCA010","NBCA007",
    "NEKA020","JJFC009","QEMA006","QEFA008","QEMA013","QEFA008","JBNE004","JDFE001",
    "QEMA013","JANE005","MDFA002","NFKA007","JANE002","BFGA427","MCCA011","QZFA036",
    "BGMA002","HHFA008","KCMA001","JANE002","NEKA020","HPPC002","HKPA005","FCFA002",
    "HMFC004","JDJE001","JGFE023","JGFC001","HMFC004","QEFA008","JDFE002","QEFA020",
    "MACA001","DELF005","NBCA005","JKFA022","NEKA020","JCGE001","JGFA005","QBFA007",
    "HMFC004","QEGA001","JCLE002","HMFC004","HGFA005","GHFA001","KCFA008","GHFA001",
    "JRGA001","EJSA001","EZCA003","HHFA014","QZMA001","EBFA010","JCLE002","HKPA004",
    "DEEA001","HHFA025","JCGE001","HFCC003","JGFE023","HMFC004","JKFC002","JKFC006",
    "NCPA002","QAMA002","LMSA002","JKFA015","JGFE023","JGFC001","FCFA009","HCFA008",
    "QZFA014","JJFC006","NBCA010","JJFA010","JDFE001","MCPA005","NEKA014","HMFC004",
    "JGFC001","HPPC002","MEKA008","JKFA025","HHFA008","NEJA001","HMFC004","QEFA008",
    "PAGA011","EDCA004","NFPA003","JKFA020","JCGE001","JKFC001","JKFC003","JGFE023",
    "JGFE023","QEFA008","HMFC004","HPNC001","JJFC010","NFKA007","NEKA012","NEKA011",
    "HMFC004","HHFA016","HMFC004","JBFC001","HHFA010","QZJA011","GAMA018","HCFA008",
    "QAMA002","HHFA002","JJFC010","HHFA008","JCGE006","NFKA007","JCAE001","DELF005",
    "HHFA016","HHFA016","HHFA008","NZFA007","JCLE002","EBFA016","JKFA006","NFEC002",
    "EBFA016","JCAE001","JCGE001","GAMA007","LMMA012","MCCA010","JCGE006","JANE005",
    "DELF005","JDFE001","QZFA023","MCCA004","HFFC002","JCAE001","HMFC004","JDFE002",
    "HHFA025","JCGE006","JCAE001","JCAE001","JCGE006","HMFC004","DELF005","JCGE006",
    "DELF005","MCCA005","JCGE006","HMFC004","FCPA001","JJFC006","FCPA001","MEKA004",
    "MCCA005","NCCA017","FCFA009","FCFA009","JLCA005","GHFA001","MBCA005","PZMA004",
    "ZCJC001","MHDA005","FCCA001","HMFC004","NCCA019","QBFA003","GHFA002","MJEC002",
    "QZMA001","MBCA001","HMFC004","QEMA010","QZFA023","QEFA008","NFMC003","MCKA002",
    "JGFC001","BAFA008","NFKA007","LACA003","HHFA016","NBCA014","GHFA001","HHMA003",
    "JGFE023","NFKA008","JCLE002","FCPA001","FCCA001","NJEA003","CBMA002","JKFA024",
    "QZMA001","HMFC004","MEKA006","FCPA001","HGPC015","QZMA001","QBFA007","NEKA020",
    "HMFC004","JGFC001","QEFA008","QEFA008","QEFA008","NFMC003","JDFE002","QEKA001",
    "JGFE023","HMFC004","HHFA025","JLCA005","JGFA005","HMFC004","JKFA024","PDFA001",
    "LCJA003","JAFC005","JBNE004","QZFA036","HMFC004","LMMA004","GHFA001","KCFA008",
    "HCFA008","JRGA001","HMFC004","DEKA001","LHMH140","JKFA016","HMFC004","EDCA005",
    "FCPA001","HGPC015","NCCA017","QZMA001","JKFC005","NFKA007","JJFC003","NJEA002",
    "HHFA025","HGPC015","LMMA004","QEFA008","QZFA014","JMBA001","FCPA001","DELF013",
    "JGFA005","NGDA002","NFKA007","QZMA004","JGFE023","QZFA036","JDFE001","JCGE006",
    "JJFA007","NCCA007","JDFE001","LMMA009","KDQA001","HFFC018","FCPA001","FCFA009",
    "LMMC002","JGFE023","JCEE001","JLCA004","MZFA013","JHFA009","LAFA019","DGLF001",
    "NDPA014","DELF005","NZFA007","JCAD001","JAFA008","DELF014","JKFC001","NJEA003",
    "NCMA002","NBCA010","FAFA014","QEFA020","HHFA016","JGFE023","QEFA017","JDFE002",
    "JJFC003","EEAF006","QZFA002","NEKA020","HPPC003","JCGE001","GHFA001","KCFA008",
    "BFGA427","LDAA001","GFFC002","HFCC001","HMQJ001","JLCA007","MHJA001","NEKA017",
    "FCPA001","HJDC001","JANH798","EDFA007","FCCA001","EPLA002","JDFE001","JKFC001",
    "NFMC003","LDFA008","NEKA020","JJFA004","HMFC004","JANE002","JJFC010","JGFE023",
    "JGFA005","QEFA020","JANE005","PDFA001","JGFC001","EJGA002","NBCA010","HFFA008",
    "HMFC004","HHFA024","MCCA011","HHFA018","FCFA009","KDFC001","JJFJ001","HMFC004",
    "JGFE023","LMMA009","EEFA003","JGFE023","JDFE002","CAFA006","HPPC003","NBCA007",
    "NEKA020","LMMC002","HHFA016","FCCA001","QEFA008","NEKA020","FCPA001","JGFA005",
    "JJFC006","JDFE001","NEKA020","HHFA016","JGFE023","FAFA010","QEFA008","JGFE023",
    "QEEB152","JKFA018","JKFA015","MCCA011","JCGE006","NCCA002","JCAE001","HHFA025",
    "KDFC001","KDQA001","EZCA003","GFFA009","JJFC010","QZFA031","DELF007","NCCA017",
    "HFMC001","DELF005","FCFA016","QZJA011","QZFA036","NEKA020","EGFA003","NHFA001",
    "EGFA003","QZLA002","NFCC408","NEKA020","NFPA001","JCLD001","MJJA001","QEKA001",
    "JGFE023","JGFE023","FCCA001","QEFA020","HMFC004","JDFE001","NEKA006","LCJA003",
    "HHFA016","NEKA011","JDFA001","HJFA004","NEJA004","LFFA002","HMFC004","HMFC004",
    "LAFA024","CBPA002","PDFA002","FCPA001","DELF005","QBFA003","JJFC010","PAGA011",
    "NHMA002","HMFC004","GEFA002","HFFC017","JDFE002","LMMC002","JDFE001","FCCA001",
    "JDFE002","HGPC015","HPPC001","DELF014","JCGE001","DELF005","QEKA001","JCLE002",
    "JCEE001","HFFC018","GHFA001","FCFA009","BFGA427","LFAA002","HMFC004","JJFJ001",
    "HPPC003","HHFA016","LMMC015","LMFA002","FAFA014","FCPA001","DELF007","JCGE001",
    "JKFA027","JKFA020","JDFE001","EGFA003","HHFA016","JJFC004","HAMA027","AFCA001",
    "QEMA013","QZEA039","JKFC002","NBCA009","HGPC015","QZMA001","JANE002","QEKA001",
    "JKFA016","CBMD002","JCFA008","JKFA020","FCPA001","NBCA006","MCCA003","JKFC001",
    "PZMA004","JCLE002","HHFA025","NFFC002","HMFC004","NFMC003","QZJA011","FCCA001",
    "NEKA020","DELF005","FCPA001","HMFC004","QZMA001","LMMA010","MJEC002","DELF014",
    "JKFA022","JAFC005","JKFA022","LCJA003","MEKA006","JHFA006","NEKA011","NDCA003",
    "JJFA005","HMFC004","DELF015","DELF005","JGNE171","JCAD001","JAFC019","JCCC001",
    "HMFC004","HMFC004","ZCJA004","JCGE001","NFPA003","LFFA002","KCFA008","KDQA001",
    "HKPA007","JKFA022","LFAA001","DELF005","HHFA025","NEKA020","NEKA011","ZCQC002",
    "HMFC004","JDFE001","GGPA001","JFFC001","LMMC002","JCGE001","JCPD001","JKFC005",
    "QEMA012","HHFA025","GGJA001","NFKA007","HHFA016","HHFA016","QZMA001","MEKA008",
    "HHFA016","JCAE001","GHFA001","HHMA003","HFFC018","GHFA001","KDQA001","JGFE023",
    "LHMH454","DELF005","GEMA001","FCPA001","DELF005","FCCA001","JKFA027","JGFE023",
    "QZMA004","PAGA011","QZMA004","NEKA020","HMFC004","HDMA007","LMMA009","JAFC005",
    "JDFE002","GFFA013","JDFE002","JKFC006","JDFE002","JDFE001","JKFA022","JKFC005",
    "EEAF006","FCFA009","KDQA001","MBCA006","FCFA009","FCFA009","HPPC002","NBCA010",
    "DELF016","GBPA002","NEKA020","JKFA002","NEKA009","FCCA001","AHFA001","LMMC002",
    "HHFA016","JLFA003","NCCA017","FCFA011","NFFC004","JKFC001","JGFE023","QAPA002",
    "HMFC004","NFKA008","JGFE023","QEFA020","CAMA013","QEFA008","JGFE023","PZMA004",
    "KCFA001","JDFE001","JGFE023","JGNE171","JGNE171","NCCA011","HHFA016","HPPA002",
    "NBCA006","FCFA009","JKFA024","HEDA001","LFAA001","JANE002","JCLE002","HCFA012",
    "HHFA008","HCFA011","NEKA009","NFMC003","QEEB152","NJCA001","DELF005","DELF005",
    "JKFA020","JGFE023","PDFA001","HHFA016","JGFE023","EGFA003","JCPD001","PAGA011",
    "EGFA002","QEEB152","JKFC005","LFAA002","QAMA002","LMMA004","DELF005","NFMC003",
    "JGFE023","NEKA020","JDFE002","JDFE001","FCPA001","MCCA011","NEKA020","LHMH140",
    "AHPC001","JKFA024","QZJA011","JDJE001","JEMA023","HGPC015","HHFA025","HFFC002",
    "JCLE002","HPPC002","HHFA002","QZGA008","FCPA001","DEKA001","FCCA001","NFKA008",
    "QEFA020","HPPC002","JKFA027","QEKA001","MEKA006","QZMA001","PAGA009","HMFC004",
    "HHSA001","DELF005","QEGA003","JEFA009","QEFA008","JGFA005","JJFC006","FCPA001",
    "JCAE001","JBNE004","DELF005","GAMA013","JKDC001","JANE002","JBNE004","GAMA018",
    "NBCA007","HHFA025","NZFA010","FCFA009","HFFC018","KCFA008","KCFA008","ZCJC001",
    "JDFE002","MEKA005","LMMC015","HHFA002","EBFA016","DELF005","PAGA011","EDCA005",
    "LFAA001","HFFC002","JCLE002","EGFA003","QEKA001","QZEA039","AHPA014","JBNE004",
    "QEFA008","CBPA002","FCPA001","QEFA017","JDDB007","PCEA002","JCGE006","GFFC005",
    "HHFA016","JCLE002","LFAA002","AHPA017","JCLE002","NBCA009","LMMC020","QAMA002",
    "JCLD001","JCLE002","HMFC004","FCFA009","HHFA008","HCFA008","GGJC002","NBCA009",
    "NBPA005","NFFC002","QZMA001","GGPA001","JJFC003","QZFA023","QEFA017","NCCB006",
    "EZFA003","NBCA001","NEKA011","JCLE002","HHFA016","NBCA010","MEKA008","MJJA001",
    "NBCA003","HHFA008","FCFA009","LMMC015","JCLE002","JDDA006","QEGA003","NBGA007",
    "FCPA001","JEMA023","FCCA001","PDFA001","JJFC010","JDFE002","HMFC004","JANE005",
    "GAMA002","QZFA023","JKFC005","PAGA011","KDQA001","QEMA013","JGFE023","JDFE002",
    "QEFA008","QEFA020","JHFA008","JDFE001","FCCA001","DCMA001","FCPA001","JDFE001",
    "JGFC001","FCFA029","JJEC001","JJFA004","FAFA015","JDFE001","JCGE001","HHFA002",
    "HHFA025","MCCA005","JCLE002","HFFC018","GHFA001","JKFA027","LMMC015","KCFA005",
    "NBPA005","HHMC001","LAMA007","JDFE001","JGFE023","FCCA001","NCMA001","FCCA001",
    "NBCA006","HPPC001","JCFA010","QEGA003","EGFA003","QEKA001","QZMA004","JKDC001",
    "JKDC001","PAGA009","DELF005","JCLD001","HHFA009","JAFA003","HNFC002","CBPA002",
    "JJFC010","JKFC002","NEKA020","JKDC001","QZFA036","JGFC001","MFKA003","DELF005",
    "JDFA023","JAFC005","LCJA003","NBCA006","HHFA016","GHFA001","HHFA002","EDFA007",
    "FCFA009","HHFA002","LFAA002","KDFC001","KCFA008","JDFE002","HPPC002","GEMA001",
    "GBPE001","JGFA005","NBGA007","DELF007","JHEA007","HHFA016","JKFA022","JKFA022",
    "HHFA025","HKPA007","BAMA004","QZFA030","JAFC005","NFKA008","QZFA036","QEMA010",
    "QEFA020","JGFA005","LJFA004","JDGE001","GGNC001","JKDC001","MEKA008","JAFC005",
    "QZMA004","DELF005","HHFA025","NFPA003","JDJE001","NBCA009","HHFA027","GHFA001",
    "KCFA008","GHFA001","JLCA007","DELF005","JGFE023","JLDA002","HPPC002","DELF014",
    "QZFA004","NGDA002","EJSA001","JCGE006","HKPA007","JJFC010","PAGA011","GAMA018",
    "NEKA020","JGFE023","JGFE023","JDFE001","JDFE001","JJCC003","BFGA427","JGNE171",
    "MEKA008","HHFA025","JKFC001","JGFC001","HHCC001","HHFA002","GHFA001","LDFA008",
    "AHEA012","NJMA003","JGFE365","EZMA001","DELF005","NBCA006","JKFA015","HPPC001",
    "HPPC002","BAFA006","MEKA008","GGNC001","NFFC002","QZGA008","DELF005","QEKA001",
    "NEKA011","HHFA008","QEKA001","HGFC016","JCCA006","QEFA008","JGFC001","FCCA001",
    "FCPA001","JJFC010","JCAE001","JKFC005","DELF014","NEKA020","LACA003","QEMA013",
    "JCLD001","FCFA002","JKFC001","HMFC004","HMFC004","HGPC015","LFAA002","LLMC004",
    "KDFC001","GHFA001","JRGA001","JCAE001","NFKA008","HPPC002","FCPA001","DELF005",
    "EDFA007","JCGE006","JJFC010","JCGE006","HKPA007","JKFA020","QAMA002","NFMC003",
    "EEAF006","HAMA010","DELF005","NEKA020","HMFC004","LMMC015","QEFA008","JGFA005",
    "QEFA017","JGFC001","JCEE001","FCCA001","JANE005","JJFC010","JDFE002","HFMC008",
    "HPNA001","CAMA022","JCAE001","NDPA002","NGPA001","JKFC001","HMFC004","JGFE023",
    "LCJA003","JDFE001","NBCA009","GHFA001","MCCA001","AHPA017","GAMA016","JJCC001",
    "NEKA020","HHFA016","MJFA002","FCFC001","FCCA001","HFCC001","DELF005","NCCA017",
    "HMFC004","JANE005","JGFE023","NFKA008","LFAA001","MACA001","QZFA031","HMFC004",
    "NFEC002","FCPA001","QZFA014","JJFC010","JKFC002","JCAE001","FCFA029","HHFA016",
    "JKFC005","LCJA003","NEKA011","NFMC003","JCLE002","JDPE002","JGFE023","JCAE001",
    "DELF005","MCCA001","HMFC004","HHFA008","LMMC001","JJFC010","JDDB007","HHFA025",
    "HHFA025","LMMC001","EEAF006","JCGE001","FCCA001","JGFC001","JDFE001","JANE002",
    "JGFC001","JJCC001","JCGE001","JDFE002","QEFA007","HGFA005","HHFA025","NEKA020",
    "JCAE001","KCFA008","GHFA001","HFFC018","JKFA027","KCFA008","HGPC015","JDFE002",
    "LFAA002","LFFA002","CBFA002","HMFC004","LMMC002","EBFA016","JKFA015","JJFC010",
    "JDFE001","JCGE001","HMFC004","GBPE001","NBMA003","QZMA001","NBCA014","NEKA017",
    "JAFC001","QEFA008","FAFA014","QEFA008","JJFC008","GBBA002","FCCA001","QEFA017",
    "FCPA001","JKFC001","JGFC001","JJFC003","MDCA011","AHPC001","NBCA006","HFCC001",
    "HGPC015","QBFA004","HHMA002","HHMA003","KDQA001","KCFA004","CBFA007","JKFA025",
    "JKFC001","QZMA005","QEGA004","DELF005","DELF005","EBFA016","JKFC005","LMMA010",
    "JANE002","JANE005","EGFA003","QEMA006","QEFA020","NEKA020","HPPC003","KEFC002",
    "FAFA014","QEFA020","JGFE023","PZMA004","JGFE023","JCGE001","ZCJC001","DELF016",
    "HPNC001","JGFE023","JCLE002","NEKA020","LMMA012","JCLE002","NCCA002","NJMA003",
    "HHFA016","FCFA009","ZCQA001","GHFA001","JDFE002","KCFA005","LHFA001","JJFC010",
    "DELF005","LMMC002","EBCA008","JDFE003","JCKE002","JGFE023","LMMA004","JDFE001",
    "EGFA003","HKPA007","HPPA003","NCPA002","FCFC004","QZMA001","LFAA002","QEFA002",
    "DELF016","DELF005","JGFA005","GHFA001","QEFA008","QEFA008","JDPE002","JGFC001",
    "PZMA004","HPPC001","JJFC010","JGFA005","JKFC006","JAFC005","NCCA017","JCLE002",
    "HHFA025","FCFA009","QZMA001","JCAE001","NEKA011","NCCA018","NCCA004","FCFA014",
    "JDFA004","MCCA011","JJFC010","JCAE001","JCAE001","HMFC004","DELF015","PDFA002",
    "FCPA001","JJFC010","AHCA022","JDFE001","JCGE006","MEKA008","QZFA014","JKFC001",
    "JCAE001","NEKA020","JKFA027","KDQA001","HHFA002","FCFA009","JDFE001","FCPA001",
    "JGFC001","JGFE023","JCAE001","FCCA001","JDFE002","JKFC002","HPPC002","JCAE001",
    "ZCJC001","QZFA004","LMMA012","NBCA010","DELF005","JCAE001","QZMA004","JJFA010",
    "KCFA008","KDFC001","FCFA009","GHFA001","NFKA008","JDFE001","FCPA001","JKFA027",
    "JKFA015","ZCQC002","JDFE001","JDFE001","QEMA004","JGFE023","JKFA027","NEKA020",
    "NEKA011","QZMA005","JCAE001","NEKA020","JGFE023","GHFA001","HHFA002","JJFC010",
    "NEKA011","FCPA001","JGFC001","JKFA020","JAFC001","JCLE002","NACA004","HMFC004",
    "JGFC001","QEFA017","JCAE001","NDCA003","JCGE006","MEKA008","HMFC004","KCFA008",
    "HHFA002","GHFA001","GHFA001","HHFA016","LMMC002","FCFA009","LFAA002","DELF005",
    "QEFA020","FCPA001","FCPA001","NCCB001","JCLE002","JDFA001","JGFA005","NFKA008",
    "JCGE006","JDFE001","GHFA002","BAMA005","NEKA020","LMMA004","JANE002","HMFC004",
    "JCAE001","JGFA005","FCPA001","FCCA001","QEFA008","NEKA011","JCGE001","JDFE001",
    "JDFE002","JGFE023","JJFA010","JJFA007","HGPC015","DELF005","NCCA017","JHEA010",
    "HHFA025","HMQJ001","HHFA025","HHFA025","KCFA005","HFFC018","LLMC004","KCFA005",
    "HPPC003","JGFE023","JDFE001","JDPE002","JGFE023","FAFA014","QZMA004","JCGE005",
    "DELF005","EDFA007","JKFA005","DELF007","JANE005","JGFE023","GAMA018","NFKA002",
    "JJFC006","QAMA002","JLFA003","HHFA016","JGFC001","GHFA001","KDQA001","JCGE001",
    "KDFC001","JJFC010","JGFC001","JDCA003","JCAE001","ZCJC001","NEKA020","LMMA012",
    "JFFC001","KDQA001","NFPA003","JCGE001","HMFC004","GAME001","KCFA005","DELF013",
    "NEKA020","LFAA001","JKFA031","JGFC001","LFAA001","LFAA001","JJFJ001","NCPA015",
    "NJEA002","JANE002","KCFA001","JGFE023","FCFA009","JGFE023","JJFC010","JCGE005",
    "JGFE023","JGFC001","HKPA005","JGFE023","NEKA020","HKPA005","NCCA012","NEKA020",
    "JGFC001","GHFA001","HJFA004","MEKA008","GHFA001","HGCA006","GBPE001","GAMA007",
    "HFFC001","JGFE365","QEKA001","MCCA010","JDFE001","HMFC004","JJFC010","JCGE006",
    "JKFA020","JJFC003","JCGE001","HMGE002","HMLE003","AMQP012","HHFE002","JVJF002",
    "DDAF008","AMQP012","HHSE002","AMQP012","AMQP012","DHPF002","DDPF002","DEPF033",
    "DDAF007","HHFE002","AMQP012","EEAF006","DDAF010","AMQP012","DDQH009","HHSE002",
    "DEPF033","HBMA006","EEAF006","DDAF008","DDAF008","AMQP012","DDQH009","HBMA006",
    "AMQP012","JKNE001","LBLD026","DEPF012","DDAF008","AMQP012","DDQH009","DDAF008",
    "AMQP012","DEPF010","DEPF033","HMQH003","AMQP012","HBMA006","EDAF007","DEPF033",
    "DDAF007","EDSF014","DDAF008","EEAF006","EBLA003","EDAF001","DDQH009","EDSF009",
    "AMQP012","DELF017","LBLD038","HHFE002","HBMA006","DEPF033","HMLE002","DEPF005",
    "DENF018","HBGD420","DEPF033","DDAF008","DASF005","LBLD025","AMQP012","AMQP012",
    "AMQP012","DDQH009","DDAF010","DEPF033","DEPF033","DDAF008","DDAF008","DEPF033",
    "DEPF033","DEPF010","JEPE002","HMLE002","DEPF033","DDAF010","DEQF005","EDAF001",
    "EEAF006","AMQP012","DDAF008","HGQE001","LBLD010","DENF018","DDQH009","DDPF002",
    "EDAF003","AMQP012","AMQP012","HMLE002","LBLD038","DDQH009","DEPF033","EDAF003",
    "EEPF001","DEPF033","LBFA023","DENF015","DEPF033","JKNE001","DDAF008","DDAF008",
    "DDAF010","HHFE006","HHFE002","EDAF007","HGQE003","DEPF033","DENF021","EDAF003",
    "DEPF033","DEPF033","AMQP012","AMQP012","HLNM001","DEPF033","LBFA023","DENF035",
    "HBMA006","DDQH009","DDAF008","JBQE001","AMQP012","EDAF003","EDAF003","AMQP012",
    "DEPF033","JKFE001","DEPF033","DEPF033","DDAF008","HMLE002","HMGE002","AMQP012",
    "HMLE002","DDAF008","HHFE004","DENF035","DDPF002","DENF018","HMLE002","DEQF001",
    "EBLA003","DDPF002","HGLE001","EDAF005","AMQP012","HHFE004","DENF035","DENF035",
    "JEGE003","DDQH009","DEPF033","AMQP012","DDAF010","JDQE003","DDAF008","DDQH009",
    "HMLE002","HBMA006","DEPF033","AMQP012","DDAF008","DEPF033","DEPF033","DEPF033",
    "HHFE006","EEAF006","AMQP012","EEAF006","HHSE002","DEPF033","JEPE002","JKNE001",
    "DDQH009","DEPF033","DDAF007","EEAF006","JEFE004","AMQP012","JDQE001","HBMA006",
    "DEPF033","EEAF006","DDAF010","DDAF008","AMQP012","DEQF001","DEQF001","DDAF010",
    "HMGE002","DEPF033","DDAF008","EBLA003","LBLD013","DEPF033","DEPF010","DEPF012",
    "HMGE002","DEPF033","DDAF007","HMGE002","HMGE002","DDAF010","DEPF033","DDAF008",
    "LBLD026","JBQE001","DEPF033","DEPF033","HESE002","DEPF033","HHFE002","DDAF008",
    "DDAF008","DEPF006","HBMA006","HBMA006","DEPF033","DDAF008","HLNM001","DEPF033",
    "DDAF008","EEAF006","DDAF010","HBMA006","DDAF010","DEPF033","JELE003","DDAF001",
    "JVJF005","DDAF007","AMQP012","DDQH009","HBMA006","JKNE001","DDAF008","HMLE002",
    "HMLE002","HLNM001","HBGD021","DDQH009","JEPE002","HMQJ001","LBLD026","DEPF033",
    "DDQH009","DEPF033","DDQH009","AMQP012","DDAF008","DDAF008","DDAF008","EEAF006",
    "DDAF008","DEPF033","DDQH009","DEPF033","EDSF016","EEPF002","EEPF002","DEPF033",
    "DDAF008","HHFE002","DEPF033","AMQP012","EZPF004","EDSF016","DEPF005","DENF035",
    "HBMA006","DDAF008","HHSE002","DEPF033","DEPF033","DDPF002","DEPF033","DDQH009",
    "DEPF010","DEPF033","AMQP012","DDAF008","AMQP012","JKNE001","EEPF002","DEPF033",
    "EDSF016","HBMA006","DDAF008","DDAF010","DDAF008","HMLE002","DASF005","DEPF033",
    "HHFE002","AMQP012","EEAF006","AMQP012","DEPF033","HBMA006","DDQH009","HLNM001",
    "DEPF033","EDSF016","EDSF004","EDLF005","HBMA006","HHSE002","DEPF033","LBLD025",
    "LBLD010","DDAF008","DDAF008","DEPF033","HHFE006","DEPF033","AMQP012","EDSF004",
    "EDSF004","DAGF001","DEPF033","DDAF008","DEPF033","AMQP012","DDQH009","DDQH009",
    "EDSF004","EDSF004","EDSF004","HBMA006","HHFE002","DDPF002","DEPF033","DEPF033",
    "DDAF007","DEPF033","DEPF033","EDSF004","EDSF004","DEPF033","EDAF003","DEPF033",
    "HBMA006","DEPF033","DENF035","DDAF008","DDQH013","DDAF008","DDQH009","EDSF004",
    "EZPF004","EDSF004","DDQH009","EDSF004","EESF007","DENF018","DEPF004","DEPF033",
    "DEPF033","EDSF004","DEQF004","AMQP012","HHSE002","EDSF004","AMQP012","DDAF008",
    "LBLD026","DEPF033","HBMA006","DEPF033","EDSF006","HMLE002","DDPF002","DEPF033",
    "EEAF006","HMLE003","AMQP012","EBLA003","EDSF004","EDSF004","EEAF006","AMQP012",
    "DDQH009","EDSF004","EDSF004","EDSF006","HHFE004","DEPF033","AMQP012","AMQP012",
    "DDAF010","DDPF002","HMQH003","DDPF002","EAJF341","DDAF008","DDAF008","DDAF008",
    "EDSF004","DDPF002","EDSF004","DEEF001","DDAF008","DENF018","HHFE006","JEPE002",
    "DEPF033","DEPF033","HHSE002","EDSF004","EGSF001","EDSF004","EDSF004","DDAF008",
    "DEPF033","DEPF033","DASF074","EDSF004","DGPF002","DDAF007","DDAF008","EEAF006",
    "HMLE002","EEAF006","EDSF004","DDAF008","EDSF004","DEPF033","DDAF008","EDSF004",
    "JVJF008","DENF035","DDAF010","HMGE001","EDSF004","EDSF004","EDSF004","EDSF004",
    "EEAF006","HBMA006","DEPF033","DENF018","DEPF033","DEPF033","DEEF001","EDSF004",
    "ECSF004","DEPF033","LBLD010","DEPF033","DEPF033","DDAF008","DEPF033","DEPF033",
    "DDAF008","EDSF004","EDSF004","EDSF004","DEPF012","EDSF004","HMLE002","DEPF033",
    "DEPF010","EDSF004","EDSF004","HMLE002","EDSF004","DEPF033","DEPF006","HEFE003",
    "DDQH009","DDQH009","EDSF004","EDSF004","DDAF007","DDAF008","DEPF006","DEPF012",
    "EPLF005","HMGE002","DDQH009","DDQH009","EDSF004","EDSF004","EBLA003","DDAF008",
    "JEPE002","DDAF008","EEPF001","EEAF006","EEAF006","DEPF033","DEPF012","JVJF008",
    "DEPF033","DDQH013","EPLF004","DEPF033","JELE003","DEPF033","HBMA006","DEPF033",
    "DDAF008","EDSF004","AMQP012","DDQH009","DDAF008","EBLA003","DEPF006","DENF035",
    "EDSF004","EDSF016","DDAF007","DEPF033","DEPF010","HGQE001","EDSF004","EDSF004",
    "EEAF006","EDSF004","AMQP012","DDAF008","EDAF001","EDAF003","HBMA006","DEPF033",
    "DENF035","HBMA006","HBMA006","DDAF008","HBMA006","DDAF008","DDAF008","EEAF004",
    "DEPF012","EDSF004","DDQH009","DEPF033","HGQE001","DEPF033","DEPF033","DDAF008",
    "EDSF004","DEPF033","DEPF033","HBMA006","EGSF001","EEAF002","JKQE001","DDAF008",
    "HBMA006","DEPF033","DDAF008","HMGE002","DEPF033","DEPF033","HGSE001","DHSF001",
    "LHMH002","DDQH009","DDPF002","HMLE002","DEPF033","DEPF033","DEPF033","DEPF033",
    "AMQP012","EDSF004","DDAF008","EEAF006","DEPF033","HMGE002","DEPF010","EGSF001",
    "DDAF008","HMLE002","DDAF008","EDSF004","EDSF004","AMQP012","DDAF008","DEPF033",
    "DEPF033","JEPE002","EDSF004","EBLA003","JCGE004","DEPF033","EDSF004","EDSF004",
    "DDAF008","EDSF004","LBLD010","DEPF033","HBMA006","EDSF004"
]

print(f"‚úÖ {len(LISTE_ACTES_AUTORISES)} codes CCAM autoris√©s")

# ============================================================================
# MAPPINGS SP√âCIALIT√âS
# ============================================================================

CATEGORIE_DICT = {
    'Chirurgie digestive': 'Digestif',
    'Chirurgie g√©n√©rale': 'Digestif',
    'Gastroent√©rologie': 'Digestif',
    'Chirurgie orthop√©dique et traumatologique': 'Orthop√©dique',
    'Orthop√©die': 'Orthop√©dique',
    'Chirurgie vasculaire': 'Vasculaire',
    'Chirurgie cardiaque': 'Vasculaire',
    'Cardiologie': 'Vasculaire',
    'Chirurgie thoracique et cardiovasculaire': 'Vasculaire',
    'Urologie': 'Urologue',
    'Gyn√©cologie-Obst√©trique': 'Gyn√©co',
    'Gyn√©cologie-obst√©trique': 'Gyn√©co',
    'ORL et chirurgie cervico-faciale': 'ORL',
    'Oto-rhino-laryngologie (ORL)': 'ORL',
    'Ophtalmologie': 'Ophtalmo',
    'Chirurgie maxillo-faciale et stomatologie': 'Stomatologie',
    'Odontologie': 'Stomatologie',
    'Stomatologie': 'Stomatologie',
    'Chirurgie plastique': 'Plasticien',
    'Chirurgie de la main': 'Plasticien',
    'Chirurgie du rachis': 'Orthop√©dique',
    'Chirurgie thoracique': 'Vasculaire',
    'Neurochirurgie': 'Neuro',
    'Dermatologie': 'Dermato',
}

AGE_PAR_SPECIALITE = {
    'Chirurgie digestive': (30, 75),
    'Gyn√©cologie-obst√©trique': (18, 45),
    'Neurochirurgie': (25, 70),
    'ORL et chirurgie cervico-faciale': (3, 65),
    'Ophtalmologie': (50, 85),
    'Chirurgie orthop√©dique et traumatologique': (40, 80),
    'Chirurgie plastique': (20, 70),
    'Stomatologie': (15, 60),
    'Urologie': (45, 80),
    'Chirurgie vasculaire': (50, 85)
}

PROBA_HOMME_PAR_SPECIALITE = {
    'Chirurgie digestive': 0.55,
    'Gyn√©cologie-obst√©trique': 0.02,
    'Neurochirurgie': 0.60,
    'ORL et chirurgie cervico-faciale': 0.50,
    'Ophtalmologie': 0.50,
    'Chirurgie orthop√©dique et traumatologique': 0.55,
    'Chirurgie plastique': 0.35,
    'Stomatologie': 0.50,
    'Urologie': 0.90,
    'Chirurgie vasculaire': 0.70
}

DP_PAR_SPECIALITE = {
    'Chirurgie digestive': ['K35','K40','K42','K80','K81','K56','K57','K64','C18','C20','K25','K26'],
    'Gyn√©cologie-obst√©trique': ['O80','O81','O82','N81','N92','D25','N97','O34','O60','Z30'],
    'Neurochirurgie': ['G93','I61','I60','S06','G95','C71','D33','M50','M51','G40'],
    'ORL et chirurgie cervico-faciale': ['J35','J34','J32','H90','C32','C10','J38','H61','H66','H81'],
    'Ophtalmologie': ['H25','H26','H33','H40','H35','H02','H05','H04','H11','H53'],
    'Chirurgie orthop√©dique et traumatologique': ['M16','M17','M19','S72','S82','M51','M47','M23','M75','S42'],
    'Chirurgie plastique': ['L90','L91','C44','T20','T21','T22','Q18','N64','Q35','Q36'],
    'Stomatologie': ['K04','K05','K07','K10','K08','C03','C04','K06','K09','S02'],
    'Urologie': ['N20','N13','C61','N40','N32','C67','N39','N31','N28','R31'],
    'Chirurgie vasculaire': ['I70','I71','I72','I80','I83','I65','I74','I77','I87','E11'],
}

# ============================================================================
# STRUCTURES DE DONN√âES
# ============================================================================

@dataclass
class Patient:
    id: int
    age: int
    sexe: int
    ccam: str
    dp: str
    duree_sejour_predite: float
    duree_op: float
    specialite: str

@dataclass
class Operation:
    id_op: int
    duree_op: float
    duree_rum: float
    spe_rss: List[str]
    medecin: Optional[int] = None
    salle: Optional[int] = None
    jour: Optional[int] = None

class Solution:
    def __init__(self, operations: List[Operation], config: dict):
        self.operations = operations
        self.config = config
        self.cout = float('inf')
        
    def copy(self):
        return Solution([copy.deepcopy(op) for op in self.operations], self.config.copy())

# ============================================================================
# MOD√àLES PYDANTIC
# ============================================================================

class HospitalConfig(BaseModel):
    nb_lits: int = 100
    nb_salles: int = 6
    t_max_salle: float = 9.0
    t_max_medecin: float = 8.0
    capacite_weekend: float = 0.5
    date_debut: str = "2026-01-01"
    date_fin: str = "2026-12-31"
    medecins: List[Dict] = [
        {"specialite": "Chirurgie digestive", "nombre": 7, "duree_moyenne": 150},
        {"specialite": "Gyn√©cologie-obst√©trique", "nombre": 3, "duree_moyenne": 80},
        {"specialite": "Neurochirurgie", "nombre": 1, "duree_moyenne": 135},
        {"specialite": "ORL et chirurgie cervico-faciale", "nombre": 2, "duree_moyenne": 130},
        {"specialite": "Ophtalmologie", "nombre": 1, "duree_moyenne": 110},
        {"specialite": "Chirurgie orthop√©dique et traumatologique", "nombre": 8, "duree_moyenne": 150},
        {"specialite": "Chirurgie plastique", "nombre": 1, "duree_moyenne": 158},
        {"specialite": "Stomatologie", "nombre": 3, "duree_moyenne": 160},
        {"specialite": "Urologie", "nombre": 5, "duree_moyenne": 90},
        {"specialite": "Chirurgie vasculaire", "nombre": 5, "duree_moyenne": 145},
    ]

class AlgoParams(BaseModel):
    algo_type: str = "genetic"
    taille_population: int = 20
    nb_generations: int = 50
    taux_mutation: float = 0.2
    taux_elitisme: float = 0.1
    t_init: float = 100.0
    t_min: float = 0.1
    alpha: float = 0.9
    max_iter: int = 25

class OptimizationRequest(BaseModel):
    nb_patients: int
    hospital_config: HospitalConfig
    algo_params: AlgoParams

# ============================================================================
# G√âN√âRATION INTELLIGENTE DES PATIENTS
# ============================================================================

def generer_patients_intelligents(nb_patients: int) -> pd.DataFrame:
    """G√©n√®re patients de mani√®re r√©aliste"""
    actes_valides = [acte for acte in LISTE_ACTES_AUTORISES if acte in CCAM_TO_SPE]
    
    if not actes_valides:
        raise RuntimeError("Aucun acte CCAM valide trouv√© dans la BDD")
    
    data = []
    for i in range(nb_patients):
        acte = random.choice(actes_valides)
        spec = CCAM_TO_SPE.get(acte, 'Chirurgie digestive')
        age_min, age_max = AGE_PAR_SPECIALITE.get(spec, (30, 75))
        age = random.randint(age_min, age_max)
        p_homme = PROBA_HOMME_PAR_SPECIALITE.get(spec, 0.5)
        sexe = 1 if random.random() < p_homme else 2
        dp_choices = DP_PAR_SPECIALITE.get(spec, ['K35'])
        dp = random.choice(dp_choices)
        
        data.append({
            'age': age,
            'sexe': sexe,
            'acte_ccam': acte,
            'dp': dp
        })
    
    return pd.DataFrame(data)

# ============================================================================
# PR√âDICTION DUR√âE DE S√âJOUR
# ============================================================================

def predire_duree_sejour(df_patients: pd.DataFrame) -> pd.DataFrame:
    """Pr√©dit la dur√©e de s√©jour via le mod√®le ML"""
    if classifier is None:
        raise HTTPException(status_code=500, detail="Mod√®le ML non charg√©")
    
    df = df_patients.copy()
    
    for col in feature_cols:
        if col not in df.columns:
            df[col] = 0
    
    X = df[feature_cols].fillna(0)
    classes_predites = classifier.predict(X)
    df["classe_predite"] = classes_predites
    
    durees = []
    for idx, row in df.iterrows():
        classe_texte = str(row["classe_predite"])
        
        if classe_texte in regressors and regressors[classe_texte] is not None:
            X_row_df = pd.DataFrame([X.iloc[idx]], columns=X.columns)
            X_scaled = scalers[classe_texte].transform(X_row_df)
            duree = regressors[classe_texte].predict(X_scaled)[0]
            durees.append(max(1, float(duree)))
        else:
            duree_defaut = {"Court": 2.0, "Moyen": 5.0, "Long": 10.0}.get(classe_texte, 5.0)
            durees.append(duree_defaut)
    
    df["duree_sejour_predite"] = durees
    return df


# ============================================================================
# ALGORITHME G√âN√âTIQUE V2 (VERSION PERFORMANTE - INSPIR√â TON AMI)
# ============================================================================

class AlgorithmeGenetiqueV2:
    def __init__(self, patients: List[Patient], config: HospitalConfig, params: AlgoParams):
        self.patients = patients
        self.config = config
        self.params = params
        self.nb_salles = config.nb_salles
        self.nb_lits = config.nb_lits
        self.t_max_salle = config.t_max_salle * 60
        self.t_max_medecin = config.t_max_medecin * 60
        self.capacite_weekend = config.capacite_weekend
        
        date_debut = datetime.strptime(config.date_debut, "%Y-%m-%d")
        date_fin = datetime.strptime(config.date_fin, "%Y-%m-%d")
        self.nb_jours_max = (date_fin - date_debut).days
        self.date_debut = date_debut
        
        self.medecins_par_spe = {}
        for m in config.medecins:
            self.medecins_par_spe[m["specialite"]] = m["nombre"]
    
    def _est_periode_reduite(self, jour: int) -> bool:
        """V√©rifie si weekend OU vacances scolaires"""
        date = self.date_debut + timedelta(days=jour)
        return date.weekday() >= 5 or est_vacances(date)
    
    def _generer_solution_initiale(self) -> Solution:
        """G√©n√®re solution r√©partie uniform√©ment"""
        operations = []
        nb_patients = len(self.patients)
        espacement = max(1, self.nb_jours_max // nb_patients)
        
        for idx, patient in enumerate(self.patients):
            jour_initial = (idx * espacement) % self.nb_jours_max
            op = Operation(
                id_op=patient.id,
                duree_op=patient.duree_op,
                duree_rum=patient.duree_sejour_predite,
                spe_rss=[patient.specialite]
            )
            op.jour = jour_initial
            operations.append(op)
        
        solution = Solution(operations, self.config.dict())
        self._affecter_ressources(solution)
        return solution
    
    def _affecter_ressources(self, solution: Solution):
        """Affecte ressources avec priorit√© d√©but p√©riode"""
        for op in solution.operations:
            if op.jour is None or op.jour >= self.nb_jours_max:
                op.jour = random.randint(0, min(30, self.nb_jours_max - 1))
            op.medecin = None
            op.salle = None
        
        operations_triees = sorted(solution.operations, key=lambda x: x.jour or 0)
        occupation_medecins = defaultdict(lambda: defaultdict(float))
        occupation_salles = defaultdict(lambda: defaultdict(float))
        lits_occupes = defaultdict(int)
        
        for op in operations_triees:
            planifie = False
            specialite = op.spe_rss[0] if op.spe_rss else "Autre"
            nb_medecins = self.medecins_par_spe.get(specialite, 1)
            jour_prefere = op.jour or 0
            
            # Strat√©gie : Essayer autour du jour pr√©f√©r√©
            for rayon in [7, 30, self.nb_jours_max]:
                debut = max(0, jour_prefere - rayon)
                fin = min(self.nb_jours_max, jour_prefere + rayon)
                jours_a_tester = list(range(debut, fin))
                random.shuffle(jours_a_tester)
                
                for jour_test in jours_a_tester:
                    # √âviter week-end/vacances si possible
                    if self._est_periode_reduite(jour_test) and rayon < 30:
                        continue
                    
                    periode_reduite = self._est_periode_reduite(jour_test)
                    capacite = self.capacite_weekend if periode_reduite else 1.0
                    t_max_salle_jour = self.t_max_salle * capacite
                    t_max_medecin_jour = self.t_max_medecin * capacite
                    
                    try:
                        duree_rum_jours = max(1, int(float(op.duree_rum)))
                    except:
                        duree_rum_jours = 3
                    
                    lits_requis = duree_rum_jours + 1
                    
                    if lits_occupes[jour_test] + lits_requis > self.nb_lits:
                        continue
                    
                    # Trouver m√©decin
                    medecin_trouve = None
                    for m in range(nb_medecins):
                        if occupation_medecins[jour_test][m] + op.duree_op <= t_max_medecin_jour:
                            medecin_trouve = m
                            break
                    
                    if medecin_trouve is None:
                        continue
                    
                    # Trouver salle
                    salle_trouvee = None
                    if specialite in ["Neurochirurgie", "Chirurgie orthop√©dique et traumatologique"]:
                        salle_test = self.nb_salles - 1
                        if occupation_salles[jour_test][salle_test] + op.duree_op <= t_max_salle_jour:
                            salle_trouvee = salle_test
                    else:
                        for s in range(self.nb_salles - 1):
                            if occupation_salles[jour_test][s] + op.duree_op <= t_max_salle_jour:
                                salle_trouvee = s
                                break
                    
                    if salle_trouvee is not None:
                        op.jour = jour_test
                        op.medecin = medecin_trouve
                        op.salle = salle_trouvee
                        occupation_medecins[jour_test][medecin_trouve] += op.duree_op
                        occupation_salles[jour_test][salle_trouvee] += op.duree_op
                        
                        for d in range(lits_requis):
                            if jour_test + d < self.nb_jours_max:
                                lits_occupes[jour_test + d] += 1
                        
                        planifie = True
                        break
                
                if planifie:
                    break
    
    def _calculer_cout(self, solution: Solution) -> float:
        """Fonction co√ªt multi-crit√®res (6 crit√®res)"""
        nb_non_planifies = sum(1 for op in solution.operations if op.jour is None)
        
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                operations_par_jour[op.jour] += 1
                for d in range(duree_rum):
                    if op.jour + d < self.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        # 1. RMSD
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations))
        else:
            rmsd = 0
        
        # 2. Variation totale (p√©nalise changements brusques)
        tv = 0
        lits_arr = [lits_par_jour.get(j, 0) for j in range(self.nb_jours_max)]
        for i in range(1, len(lits_arr)):
            tv += abs(lits_arr[i] - lits_arr[i-1])
        
        # 3. P√©nalit√© dernier jour
        if lits_par_jour:
            dernier_jour = max(k for k, v in lits_par_jour.items() if v > 0)
            penalite_dernier_jour = lits_par_jour[dernier_jour]
        else:
            penalite_dernier_jour = 0
        
        # 4. Concentration op√©rations
        nb_ops = list(operations_par_jour.values())
        if nb_ops:
            max_ops_jour = max(nb_ops)
            penalite_concentration = max_ops_jour
        else:
            penalite_concentration = 0
        
        # Normalisation et pond√©ration
        max_TV = self.nb_jours_max * self.nb_salles
        max_RMSD = self.nb_lits
        max_lits_last = self.nb_lits
        max_non_affectees = len(solution.operations)
        
        cout_total = (
            (65 / max(max_TV, 1)) * tv +
            (35 / max(max_RMSD, 1)) * rmsd +
            (20 / max(max_lits_last, 1)) * penalite_dernier_jour +
            (150 / max(max_non_affectees, 1)) * nb_non_planifies +
            (10 / max(max_ops_jour if nb_ops else 1, 1)) * penalite_concentration
        )
        
        solution.cout = cout_total
        return cout_total
    
    def _selection(self, population: List[Solution]) -> Solution:
        """S√©lection par tournoi"""
        tournoi = random.sample(population, min(3, len(population)))
        return min(tournoi, key=lambda s: s.cout)
    
    def _croisement(self, parent1: Solution, parent2: Solution) -> Solution:
        """Croisement √† un point"""
        enfant = Solution([copy.deepcopy(op) for op in parent1.operations], parent1.config)
        point_croisement = random.randint(0, len(enfant.operations))
        
        for i in range(point_croisement, len(enfant.operations)):
            if parent2.operations[i].jour is not None:
                enfant.operations[i].jour = parent2.operations[i].jour
        
        self._affecter_ressources(enfant)
        return enfant
    
    def _mutation(self, solution: Solution):
        """Mutation par d√©calage temporel"""
        for op in solution.operations:
            if random.random() < self.params.taux_mutation:
                if op.jour is not None:
                    decalage = random.randint(-10, 10)
                    op.jour = max(0, min(self.nb_jours_max - 1, op.jour + decalage))
        
        self._affecter_ressources(solution)
    
    def optimiser(self) -> Solution:
        """Ex√©cute l'algorithme g√©n√©tique"""
        population = []
        for _ in range(self.params.taille_population):
            sol = self._generer_solution_initiale()
            self._calculer_cout(sol)
            population.append(sol)
        
        meilleure_solution = min(population, key=lambda s: s.cout)
        
        for gen in range(self.params.nb_generations):
            population_triee = sorted(population, key=lambda s: s.cout)
            nb_elites = int(self.params.taille_population * self.params.taux_elitisme)
            nouvelle_population = population_triee[:nb_elites]
            
            while len(nouvelle_population) < self.params.taille_population:
                parent1 = self._selection(population)
                parent2 = self._selection(population)
                enfant = self._croisement(parent1, parent2)
                self._mutation(enfant)
                self._calculer_cout(enfant)
                nouvelle_population.append(enfant)
            
            population = nouvelle_population
            meilleure = min(population, key=lambda s: s.cout)
            
            if meilleure.cout < meilleure_solution.cout:
                meilleure_solution = meilleure
        
        return meilleure_solution

# ============================================================================
# RECUIT SIMUL√â V2 (VERSION PERFORMANTE - INSPIR√â TON AMI)
# ============================================================================

class RecuitSimuleV2:
    def __init__(self, patients: List[Patient], config: HospitalConfig, params: AlgoParams):
        self.patients = patients
        self.config = config
        self.params = params
        self.nb_salles = config.nb_salles
        self.nb_lits = config.nb_lits
        self.t_max_salle = config.t_max_salle * 60
        self.t_max_medecin = config.t_max_medecin * 60
        self.capacite_weekend = config.capacite_weekend
        
        date_debut = datetime.strptime(config.date_debut, "%Y-%m-%d")
        date_fin = datetime.strptime(config.date_fin, "%Y-%m-%d")
        self.nb_jours_max = (date_fin - date_debut).days
        self.date_debut = date_debut
        
        self.medecins_par_spe = {}
        for m in config.medecins:
            self.medecins_par_spe[m["specialite"]] = m["nombre"]
    
    def _est_periode_reduite(self, jour: int) -> bool:
        date = self.date_debut + timedelta(days=jour)
        return date.weekday() >= 5 or est_vacances(date)
    
    def _generer_solution_initiale(self) -> Solution:
        operations = []
        nb_patients = len(self.patients)
        espacement = max(1, self.nb_jours_max // nb_patients)
        
        for idx, patient in enumerate(self.patients):
            jour_initial = (idx * espacement) % self.nb_jours_max
            op = Operation(
                id_op=patient.id,
                duree_op=patient.duree_op,
                duree_rum=patient.duree_sejour_predite,
                spe_rss=[patient.specialite]
            )
            op.jour = jour_initial
            operations.append(op)
        
        solution = Solution(operations, self.config.dict())
        self._affecter_ressources(solution)
        return solution
    
    def _affecter_ressources(self, solution: Solution):
        """Identique √† AlgorithmeGenetiqueV2"""
        for op in solution.operations:
            if op.jour is None or op.jour >= self.nb_jours_max:
                op.jour = random.randint(0, min(30, self.nb_jours_max - 1))
            op.medecin = None
            op.salle = None
        
        operations_triees = sorted(solution.operations, key=lambda x: x.jour or 0)
        occupation_medecins = defaultdict(lambda: defaultdict(float))
        occupation_salles = defaultdict(lambda: defaultdict(float))
        lits_occupes = defaultdict(int)
        
        for op in operations_triees:
            planifie = False
            specialite = op.spe_rss[0] if op.spe_rss else "Autre"
            nb_medecins = self.medecins_par_spe.get(specialite, 1)
            jour_prefere = op.jour or 0
            
            for rayon in [7, 30, self.nb_jours_max]:
                debut = max(0, jour_prefere - rayon)
                fin = min(self.nb_jours_max, jour_prefere + rayon)
                jours_a_tester = list(range(debut, fin))
                random.shuffle(jours_a_tester)
                
                for jour_test in jours_a_tester:
                    if self._est_periode_reduite(jour_test) and rayon < 30:
                        continue
                    
                    periode_reduite = self._est_periode_reduite(jour_test)
                    capacite = self.capacite_weekend if periode_reduite else 1.0
                    t_max_salle_jour = self.t_max_salle * capacite
                    t_max_medecin_jour = self.t_max_medecin * capacite
                    
                    try:
                        duree_rum_jours = max(1, int(float(op.duree_rum)))
                    except:
                        duree_rum_jours = 3
                    
                    lits_requis = duree_rum_jours + 1
                    
                    if lits_occupes[jour_test] + lits_requis > self.nb_lits:
                        continue
                    
                    medecin_trouve = None
                    for m in range(nb_medecins):
                        if occupation_medecins[jour_test][m] + op.duree_op <= t_max_medecin_jour:
                            medecin_trouve = m
                            break
                    
                    if medecin_trouve is None:
                        continue
                    
                    salle_trouvee = None
                    if specialite in ["Neurochirurgie", "Chirurgie orthop√©dique et traumatologique"]:
                        salle_test = self.nb_salles - 1
                        if occupation_salles[jour_test][salle_test] + op.duree_op <= t_max_salle_jour:
                            salle_trouvee = salle_test
                    else:
                        for s in range(self.nb_salles - 1):
                            if occupation_salles[jour_test][s] + op.duree_op <= t_max_salle_jour:
                                salle_trouvee = s
                                break
                    
                    if salle_trouvee is not None:
                        op.jour = jour_test
                        op.medecin = medecin_trouve
                        op.salle = salle_trouvee
                        occupation_medecins[jour_test][medecin_trouve] += op.duree_op
                        occupation_salles[jour_test][salle_trouvee] += op.duree_op
                        
                        for d in range(lits_requis):
                            if jour_test + d < self.nb_jours_max:
                                lits_occupes[jour_test + d] += 1
                        
                        planifie = True
                        break
                
                if planifie:
                    break
    
    def _calculer_cout(self, solution: Solution) -> float:
        """Identique √† AlgorithmeGenetiqueV2"""
        nb_non_planifies = sum(1 for op in solution.operations if op.jour is None)
        
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                operations_par_jour[op.jour] += 1
                for d in range(duree_rum):
                    if op.jour + d < self.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations))
        else:
            rmsd = 0
        
        tv = 0
        lits_arr = [lits_par_jour.get(j, 0) for j in range(self.nb_jours_max)]
        for i in range(1, len(lits_arr)):
            tv += abs(lits_arr[i] - lits_arr[i-1])
        
        if lits_par_jour:
            dernier_jour = max(k for k, v in lits_par_jour.items() if v > 0)
            penalite_dernier_jour = lits_par_jour[dernier_jour]
        else:
            penalite_dernier_jour = 0
        
        nb_ops = list(operations_par_jour.values())
        if nb_ops:
            max_ops_jour = max(nb_ops)
            penalite_concentration = max_ops_jour
        else:
            penalite_concentration = 0
        
        max_TV = self.nb_jours_max * self.nb_salles
        max_RMSD = self.nb_lits
        max_lits_last = self.nb_lits
        max_non_affectees = len(solution.operations)
        
        cout_total = (
            (65 / max(max_TV, 1)) * tv +
            (35 / max(max_RMSD, 1)) * rmsd +
            (20 / max(max_lits_last, 1)) * penalite_dernier_jour +
            (150 / max(max_non_affectees, 1)) * nb_non_planifies +
            (10 / max(max_ops_jour if nb_ops else 1, 1)) * penalite_concentration
        )
        
        solution.cout = cout_total
        return cout_total
    
    def _generer_voisin(self, solution: Solution) -> Solution:
        """G√©n√®re voisin par permutation/d√©calage"""
        voisin = solution.copy()
        
        # Permuter 2 op√©rations
        if len(voisin.operations) >= 2:
            i, j = random.sample(range(len(voisin.operations)), 2)
            op1 = voisin.operations[i]
            op2 = voisin.operations[j]
            
            if op1.jour is not None and op2.jour is not None:
                op1.jour, op2.jour = op2.jour, op1.jour
        
        # D√©caler quelques op√©rations
        for op in random.sample(voisin.operations, min(5, len(voisin.operations))):
            if op.jour is not None:
                decalage = random.randint(-7, 7)
                op.jour = max(0, min(self.nb_jours_max - 1, op.jour + decalage))
        
        self._affecter_ressources(voisin)
        return voisin
    
    def optimiser(self) -> Solution:
        """Ex√©cute le recuit simul√©"""
        solution_courante = self._generer_solution_initiale()
        self._calculer_cout(solution_courante)
        meilleure_solution = solution_courante.copy()
        
        temperature = self.params.t_init
        iteration = 0
        
        while temperature > self.params.t_min and iteration < self.params.max_iter * 100:
            voisin = self._generer_voisin(solution_courante)
            self._calculer_cout(voisin)
            
            delta_cout = voisin.cout - solution_courante.cout
            
            if delta_cout < 0 or random.random() < math.exp(-delta_cout / temperature):
                solution_courante = voisin
                
                if solution_courante.cout < meilleure_solution.cout:
                    meilleure_solution = solution_courante.copy()
            
            temperature *= self.params.alpha
            iteration += 1
        
        return meilleure_solution

# ============================================================================
# ENDPOINTS API
# ============================================================================

@app.get("/")
def root():
    return {
        "message": "API Optimisation Planning Hospitalier V3.0",
        "version": "3.0",
        "algorithms": ["genetic_v2", "annealing_v2"],
        "endpoints": ["/health", "/optimize"]
    }

@app.get("/health")
def health_check():
    return {
        "status": "healthy",
        "model_loaded": classifier is not None,
        "ccam_codes": len(CCAM_TO_SPE),
        "actes_autorises": len(LISTE_ACTES_AUTORISES),
        "vacances_scolaires": len(VACANCES_SCOLAIRES)
    }

@app.post("/optimize")
async def optimize_planning(request: OptimizationRequest):
    try:
        print(f"üöÄ D√©but optimisation : {request.nb_patients} patients")
        
        # 1. G√©n√©rer patients intelligemment
        df_patients = generer_patients_intelligents(request.nb_patients)
        print(f"‚úÖ Patients g√©n√©r√©s: {len(df_patients)}")
        
        # 2. Pr√©dire dur√©es de s√©jour (ML)
        df_patients = predire_duree_sejour(df_patients)
        print(f"‚úÖ Dur√©es s√©jour pr√©dites")
        
        # 3. Cr√©er objets Patient
        patients = []
        for idx, row in df_patients.iterrows():
            specialite = CCAM_TO_SPE.get(row["acte_ccam"], "Chirurgie digestive")
            
            # Trouver dur√©e op√©ration selon sp√©cialit√©
            duree_op = 120  # D√©faut
            for m in request.hospital_config.medecins:
                if m["specialite"] == specialite:
                    duree_op = m["duree_moyenne"]
                    break
            
            patient = Patient(
                id=idx,
                age=int(row["age"]),
                sexe=int(row["sexe"]),
                ccam=row["acte_ccam"],
                dp=row["dp"],
                duree_sejour_predite=float(row["duree_sejour_predite"]),
                duree_op=float(duree_op),
                specialite=specialite
            )
            patients.append(patient)
        
        print(f"‚úÖ {len(patients)} objets Patient cr√©√©s")
        
        # 4. Lancer algorithme d'optimisation
        print(f"üß¨ Lancement algorithme: {request.algo_params.algo_type}")
        
        if request.algo_params.algo_type == "genetic":
            algo = AlgorithmeGenetiqueV2(patients, request.hospital_config, request.algo_params)
        elif request.algo_params.algo_type == "annealing":
            algo = RecuitSimuleV2(patients, request.hospital_config, request.algo_params)
        else:
            # Par d√©faut, utiliser g√©n√©tique
            algo = AlgorithmeGenetiqueV2(patients, request.hospital_config, request.algo_params)
        
        solution = algo.optimiser()
        print(f"‚úÖ Optimisation termin√©e - Co√ªt: {solution.cout:.2f}")
        
        # 5. Formater r√©sultats
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        operations_par_specialite = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                operations_par_jour[op.jour] += 1
                
                patient = next(p for p in patients if p.id == op.id_op)
                operations_par_specialite[patient.specialite] += 1
                
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                for d in range(duree_rum):
                    if op.jour + d < algo.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        # Planning d√©taill√©
        planning = []
        date_debut = datetime.strptime(request.hospital_config.date_debut, "%Y-%m-%d")
        
        for op in solution.operations:
            if op.jour is not None:
                patient = next(p for p in patients if p.id == op.id_op)
                date_operation = date_debut + timedelta(days=op.jour)
                
                planning.append({
                    "patient_id": op.id_op,
                    "age": patient.age,
                    "sexe": patient.sexe,
                    "ccam": patient.ccam,
                    "dp": patient.dp,
                    "specialite": patient.specialite,
                    "date_operation": date_operation.strftime("%Y-%m-%d"),
                    "jour": op.jour,
                    "salle": op.salle if op.salle is not None else 0,
                    "medecin": op.medecin if op.medecin is not None else 0,
                    "duree_op": op.duree_op,
                    "duree_sejour": op.duree_rum,
                    "date_souhaitee": 0,
                    "ecart_jours": 0,
                    "est_weekend": algo._est_periode_reduite(op.jour),
                })
        
        # Trier par date
        planning = sorted(planning, key=lambda x: x["jour"])
        
        # Occupation lits par jour
        occupation_lits = []
        for jour in sorted(lits_par_jour.keys()):
            date = date_debut + timedelta(days=jour)
            occupation_lits.append({
                "jour": jour,
                "date": date.strftime("%Y-%m-%d"),
                "nb_lits": lits_par_jour[jour],
                "est_weekend": algo._est_periode_reduite(jour)
            })
        
        # Op√©rations par jour
        operations_jour = []
        for jour in sorted(operations_par_jour.keys()):
            date = date_debut + timedelta(days=jour)
            operations_jour.append({
                "jour": jour,
                "date": date.strftime("%Y-%m-%d"),
                "nb_operations": operations_par_jour[jour],
                "est_weekend": algo._est_periode_reduite(jour)
            })
        
        # Op√©rations par sp√©cialit√©
        specialites = [
            {"specialite": spe, "nb_operations": nb}
            for spe, nb in operations_par_specialite.items()
        ]
        
        # Calcul RMSD
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = float(np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations)))
        else:
            rmsd = 0.0
        
        # Statistiques suppl√©mentaires
        nb_planifies = len([op for op in solution.operations if op.jour is not None])
        taux_planification = (nb_planifies / len(patients)) * 100 if patients else 0
        
        # Calcul variation totale
        lits_arr = [lits_par_jour.get(j, 0) for j in range(algo.nb_jours_max)]
        tv = sum(abs(lits_arr[i] - lits_arr[i-1]) for i in range(1, len(lits_arr)))
        
        print(f"‚úÖ R√©sultats: {nb_planifies}/{len(patients)} patients planifi√©s ({taux_planification:.1f}%)")
        
        return {
            "success": True,
            "algorithm": request.algo_params.algo_type,
            "nb_patients": len(patients),
            "nb_planifies": nb_planifies,
            "taux_planification": round(taux_planification, 2),
            "cout_total": float(solution.cout),
            "rmsd_lits": rmsd,
            "variation_totale": float(tv),
            "planning": planning,
            "occupation_lits": occupation_lits,
            "operations_par_jour": operations_jour,
            "operations_par_specialite": specialites,
            "statistiques": {
                "nb_jours_utilises": len(operations_par_jour),
                "occupation_moyenne_lits": round(moyenne, 2) if occupations else 0,
                "occupation_max_lits": max(occupations) if occupations else 0,
                "nb_operations_weekend": sum(1 for p in planning if p["est_weekend"]),
                "premier_jour": min(operations_par_jour.keys()) if operations_par_jour else 0,
                "dernier_jour": max(operations_par_jour.keys()) if operations_par_jour else 0
            }
        }
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Erreur optimisation: {str(e)}")

# ============================================================================
# LANCEMENT SERVEUR
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8000))
    
    # Configuration optimis√©e pour Render
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=port,
        timeout_keep_alive=300,  # 5 minutes timeout
        timeout_notify=300,
        log_level="info"
    )

