"""
API FastAPI - Optimisation Planning Hospitalier V3.0 FINALE
Avec algorithmes Génétique2 et RecuitSimulé2 (version performante)
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import joblib
import pandas as pd
import numpy as np
from typing import List, Dict, Optional
import os
import random
import copy
import math
from datetime import datetime, timedelta
from dataclasses import dataclass
from collections import defaultdict
import warnings
from sklearn.exceptions import DataConversionWarning

# Supprimer warnings sklearn
warnings.filterwarnings('ignore', category=UserWarning, module='sklearn')
warnings.filterwarnings('ignore', category=DataConversionWarning)

# ============================================================================
# INITIALISATION FASTAPI
# ============================================================================

app = FastAPI(title="API Optimisation Hospitalière V3", version="3.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================================
# VACANCES SCOLAIRES 2025-2026
# ============================================================================

VACANCES_SCOLAIRES = [
    (datetime(2025, 2, 8), datetime(2025, 2, 23)),   # Hiver
    (datetime(2025, 4, 5), datetime(2025, 4, 21)),   # Printemps
    (datetime(2025, 7, 5), datetime(2025, 9, 1)),    # Été
    (datetime(2025, 10, 18), datetime(2025, 11, 3)), # Toussaint
    (datetime(2025, 12, 20), datetime(2026, 1, 5)),  # Noël
    (datetime(2026, 2, 7), datetime(2026, 2, 22)),   # Hiver 2026
]

def est_vacances(date_jour: datetime) -> bool:
    """Vérifie si une date est pendant les vacances scolaires"""
    return any(debut <= date_jour <= fin for debut, fin in VACANCES_SCOLAIRES)

# ============================================================================
# CHARGEMENT MODÈLE ML
# ============================================================================

print("Chargement du modèle ML...")
try:
    model_path = os.path.join(os.path.dirname(__file__), "modele_duree.pkl")
    model_data = joblib.load(model_path)
    classifier = model_data["classifier"]
    regressors = model_data["regressors"]
    scalers = model_data["scalers"]
    feature_cols = model_data["feature_cols"]
    print(f"✅ Modèle chargé ({len(feature_cols)} features)")
except Exception as e:
    print(f"❌ Erreur modèle: {e}")
    classifier, regressors, scalers, feature_cols = None, None, None, None

# ============================================================================
# CHARGEMENT BDD (MAPPING CCAM → SPÉCIALITÉ)
# ============================================================================

print("Chargement BDD CCAM...")
try:
    bdd_path = os.path.join(os.path.dirname(__file__), "bdd_traitee_1_classified.csv")
    df_bdd = pd.read_csv(bdd_path)
    
    CCAM_TO_SPE = {}
    for _, row in df_bdd.iterrows():
        acte = row["acte_classant"]
        if pd.notna(row["Classification"]):
            classification = str(row["Classification"])
            premiere_spe = classification.split(";")[0].strip()
            CCAM_TO_SPE[acte] = premiere_spe
    
    print(f"✅ BDD chargée: {len(CCAM_TO_SPE)} codes CCAM mappés")
except Exception as e:
    print(f"❌ Erreur BDD: {e}")
    CCAM_TO_SPE = {}

# ============================================================================
# 🔥 LISTE COMPLÈTE DES 2910 CODES CCAM AUTORISÉS
# ============================================================================


LISTE_ACTES_AUTORISES = [
    "HMFC004","FCFA009","JDDB007","JGFE023","LFAA002","JCAE001","DELF005","FCCA001",
    "NHDA009","DEKA001","EBFA002","FCCA001","JJFC010","DELF005","HMFC004","JKFA027",
    "QZMA001","QZFA038","JKDC001","NEKA020","JCAE001","HHFA002","HFFC018","QEFA020",
    "JDFE001","JGFA005","QEGA004","JJFC003","JCAE001","JDFE001","JANE005","HMFC004",
    "NEKA009","JFFC001","JKDC001","JJFC006","HHCC007","JKFC002","NEKA020","JKDC001",
    "NEKA005","HHFA016","KDQA001","KCFA005","LFAA002","JGFE023","JCGE005","JDFE001",
    "LFFA002","MJFA013","LMMC002","GDFA008","EDFA007","JEMA023","HPPC002","FCPA001",
    "DELF005","JKFA015","JCPD001","JCGE006","JKFA022","MACA001","BAMA004","LFAA002",
    "JJFC010","JKFA022","GFFA029","LMMA004","FCPA001","JCGE006","JCFE003","QEFA020",
    "JDFE002","JANE005","JGFE023","BFGA427","JBMC001","HMFC004","HMFC004","ZCJC001",
    "NEKA011","HHFA008","LFAA002","GHFA001","MAFA004","GHFA001","JDDB007","JDDB007",
    "LDFA008","JANE005","DELF005","CBPA002","HMFC004","LMMC002","HNFA007","LAFA019",
    "QZFA036","NBCA008","JJFJ001","JLCA009","HHCA001","EBFA016","ZCJA004","LMMA004",
    "EGFA002","QZFA035","DELF014","HHQE005","NFKA007","LHMA011","LMSA002","HHEE001",
    "HMFC004","JDFE002","HCFA008","QEFA008","LMMC002","GFFC002","JCLE002","JCLE002",
    "HMFC004","JGFE023","NBCA007","HHFA016","GHFA001","HNFA007","FCFA009","FCFA009",
    "QEFA020","JGFE023","JANE002","JGFE365","HMFC004","NBCA006","JJJC001","MBCA005",
    "FAFA014","LDFA008","JKFA027","HHFA025","HMFC004","HMFC004","JCGE006","FCFA029",
    "NEKA020","JJFC010","JCPD001","HKPA007","MEKA008","JKFC001","DELF005","JDDB005",
    "QEFA012","HDFA002","QEFA008","QEMA004","JDFE001","DCMA001","HPPC003","JJFC010",
    "JDFE001","JKFC002","JKFC005","BFGA427","QBFA006","EZSA004","JCGE006","NCCA005",
    "HGCC031","FCFC005","FCFA009","KCFA008","HHFA016","HHFA025","MCPA013","JEFA003",
    "JCGE006","JDFE003","JGFE023","MJJA004","JDFE002","NEKA020","NFMC003","NJPA018",
    "JJFC010","MCCA005","JGFE023","JCLE002","QEKA001","LFFA002","PAGA009","HHFA016",
    "NBCA007","LMMC002","QZMA001","JAGF001","QEFA020","HFFC018","JDFE001","JKFA022",
    "NEKA020","JEFA002","MCCA005","JJFA005","LCJA003","HMFC004","HKPA001","FCFA009",
    "HFFC018","FCFA009","NCCA017","JGFE023","LFFA002","HHFA016","EZCA003","JCGE006",
    "DCMA001","HFFC001","QEFA019","QEFA008","PZMA004","FCPA001","JKDC001","NGPA002",
    "MEKA002","BAFA006","LMMC002","HPPC003","NBCA006","HGPC015","HGPC015","KCFA005",
    "MEMA012","JGFE023","JCAE001","LMMC002","NCPA010","JKFA027","EGFA003","HFFC018",
    "NFMC003","NFKA008","HHFA008","JANE005","JJFC010","JCGE006","JAFC005","JJPC003",
    "DELF005","NHDA008","ECCA003","MBCA005","JDFE001","JCLE002","JCAE001","NEKA014",
    "NEKA011","HGPA004","JDJE001","GHFA001","FCFA009","DELF005","LMMC015","KCFA005",
    "LFAA002","JKFC005","LDFA008","FCFA009","JGFC001","HFCC003","EBFA016","FCCA001",
    "DELF005","DEKA001","EBFA016","JKFA020","JGFA005","EGFA001","JGFE023","HMFC004",
    "JMMA002","JKFC001","LFFA002","JKFA024","LFAA001","HMLE002","MCCA008","JGFC001",
    "QEKA001","QEFA008","QEMA010","HKPA005","JDPE001","JCGE001","LFKA001","NEKA005",
    "JJFC003","FCFA009","KCFA005","QZMA001","KCFA005","JJFC006","JLDA002","JDFE003",
    "LHCA010","JANE005","NEFA001","HHFA004","DELF014","FCPA001","QEFA008","PZMA004",
    "EBAF010","MEKA006","JKFA028","NBCA010","JANE002","NJMA002","LMMA004","LBGA004",
    "QZFA036","LFFA002","PDFA001","JGFE023","DELF005","KCFA011","JCGE001","JJFC010",
    "HMFC004","NEKA005","DEKA002","JAFC008","LJCA002","HMFC004","NCCA016","HMFC004",
    "DELF005","GGPA001","HHFA027","HPPC002","HHFA016","GFFA009","JDFE003","HHFA025",
    "JKFC005","HJFA004","EDFA007","FCPA001","FCPA001","QEFA008","DELF014","EEAF006",
    "DELF005","HMFC004","JFFC002","JKFC005","JGFE023","HJFA004","EGFA002","HFFC002",
    "JLFA003","JCGE001","NCCA017","MEKA008","JDFE002","FCCA001","HHFA002","QEFA017",
    "DELF005","JANE002","PDFA001","AHCA020","BFGA427","JCLE002","DELF005","NBCA010",
    "GFFC005","JCLE002","HMFC004","LMMC002","KCFA008","GHFA001","KCFA005","JEFA002",
    "LDAA001","JGFE023","LHCA010","HMFC004","PAGA009","NEKA005","FCCA001","DELF005",
    "QEMA013","JDFE001","JKFC005","QZFA011","JJFC003","JJFC006","HKSD001","HPPC002",
    "HFFC018","FCCA001","JDFE001","JDFE001","QEFA017","JANE005","DCMA001","NFFA004",
    "JAFC001","JDFE001","GFFA009","HMFC004","MEKA009","JCAE001","NFFC004","HGPA004",
    "KCFA005","HFFA008","MBPA001","KCFA008","JANE002","KCFA008","JKFA032","JGFE023",
    "JGFE023","JDFE001","NEKA020","HHFA008","CBMA002","EEAF006","PZMA004","DELF005",
    "JGFE023","JKFC001","JFFC002","JKFC005","HHFA008","QEEB152","DELF005","JAFC019",
    "NFKA008","QEFA008","JHFA008","JDJE001","QEGA001","JDFE001","JANE002","JKFC005",
    "NCCA010","NBCA014","MCCA005","HPPC003","HHFA008","DELF007","HMFC004","JKFA022",
    "HMFC004","HHFA016","FAFA014","HMFC004","DELF005","NHMA002","HHFA025","QEFA008",
    "HPPC003","LMMA006","HMFC004","NEKA020","HHFA016","HFFC018","JGFC001","JANE005",
    "GGNC001","QEGA004","JANE005","JDFA023","NEKA020","JCNE003","ECNF002","NEKA020",
    "JGFE023","NEEA002","DELF005","NBCA003","HMFC004","NBCA010","QBFA007","HCFA008",
    "HLFC027","MCCA011","NEKA020","JDDB007","HHFA025","JGFE023","HJFA004","HMFC004",
    "NHMA002","HJFC031","PZMA004","EEAF006","FCPA001","HHFA025","JDFE001","JKFC002",
    "NEKA020","JGFE023","FCCA001","QZFA014","JGFE023","FCPA001","JCLE002","JDFE001",
    "NCCA012","JCGE001","NJCA001","JCGE001","NEKA020","DELF005","MCCA005","LMMA006",
    "NEKA020","KCFA008","JDDB007","KCFA005","KCFA005","LDFA008","JJFC010","NEEA002",
    "HHFA008","JKFC001","HHFA024","JMFA001","QZMA004","JKFA022","JCNE003","GFFC002",
    "JBNE004","JJFC006","NEKA020","JCPD001","NBCA005","HHFA016","MBCA011","JHQA002",
    "JHFA006","JGFC001","FCPA001","LDAA001","HMFC004","NCCA004","KCFA008","FCFA009",
    "KDQA001","HHFA016","JANE002","LFAA002","DELF005","QZJA011","NHDA011","HDFA008",
    "JKFC001","NFJA001","NEKA020","FCPA001","HPPC001","QEFA020","JDFE002","EEAF006",
    "LFAA002","QZJA011","LDFA008","FCCA001","JJFC003","JJFC003","NEKA020","JHFA013",
    "JKFC002","PAGA011","EEAF006","NZFA010","MCCB001","FCFA009","KDQA001","HKPA007",
    "NELA002","HMFC004","FAFA014","NDCA003","FCPA001","FCPA001","LHMA011","JJFC003",
    "HFFC002","JGFE023","JDFE001","HPNC001","LFAA002","GFFC005","QZMA001","NCCA016",
    "JCLE002","JCKE002","JCAE001","QEKA001","JANE002","JGFE023","JCPD001","JDFE001",
    "NEKA020","PDFA001","JCGE001","NDPA011","NEKA020","JCAE001","JHKA004","NEKA011",
    "MCCB004","KCFA008","JGFE023","PDFA001","HHFA025","JGFC001","QEFA008","DELF014",
    "NDPA011","FCCA001","FCPA001","EBFA016","HFFC002","JKFA028","LFFA002","HPPC003",
    "NEKA020","HMFC004","JGFE023","JCAE001","DELF005","KDQA001","KCFA008","HFMC001",
    "HPNC001","DCMA001","KCFA008","LMMC002","PZMA004","PAGA009","EBFA016","JGFE023",
    "JGFE023","NCCA004","JAFC019","MCCA005","QEFA008","FCPA001","LBGA004","JDFE002",
    "PZMA004","JKFA020","JCGE006","JDFE001","JGFE023","QAGA004","NEKA004","JKGD002",
    "NGFA001","JGFC001","HGPC015","NEKA020","QZJA011","FCPA001","JDFE001","DELF005",
    "HFCC003","JGFE023","GAMA016","MCCA005","LDFA008","NBCA010","HHFA008","FCFA009",
    "FAFA015","FCCA001","QEFA020","QEFA017","JGFE023","JANE002","JCGE001","HMFC004",
    "JGFC001","KDFA001","JCAE001","MEKA008","EJBA001","HAMA002","FCFA009","FCFA009",
    "HHFA024","GFFC002","DELF005","JLCA005","GBPA002","NFKA003","HPPC002","FCPA001",
    "DELF005","JJFJ001","HMFC004","EGFA003","NEKA020","NBCA004","HFFC018","QEFA020",
    "JKFC002","HHFA008","JAFC005","QEFA008","JGFA005","DEKA001","JDFE001","QEFA020",
    "JANE002","QBPA001","JDFE001","JCLE002","DHFA002","GFFC002","HHFA025","HMFC004",
    "JDFE001","JCAH001","JDDB007","EEAF006","HHFA016","HHFA002","JGFC001","NEKA020",
    "FCPA001","HKPA007","HFFC002","BAMA004","JCAE001","NFMC003","MCCA003","QZFA014",
    "LHCA010","HMFC004","QEFA008","NCCA013","QZFA036","JGFE023","QZFA036","JGFC001",
    "DELF005","HMFC004","HMFC004","GHFA001","FCFA009","HFMC001","KCFA008","HMFC004",
    "HMFC004","JGFE023","JCAH001","JMPA001","QEDA004","EDFA007","DELF007","PDFA002",
    "HFFC018","NDFA002","JGFE023","HHFA010","HMFC004","QEFA008","JCNE004","AHPA006",
    "DCJA001","HMFC004","JHAA003","JKFA022","LHMA011","MJCA012","DDAF008","GHFA001",
    "HFMC003","KCFA008","GHFA001","JJFA010","JEMA023","JJFC010","NCCA001","ZCJC001",
    "HMFC004","NEKA020","LHCA010","FCCA001","JDFE002","DELF005","NDFA002","NEKA011",
    "HGPA004","HFFC002","JGFE023","JKFC001","LHMA011","LMMA004","JCLE002","GHFA001",
    "LMMA004","JBFC001","JDNE001","JDFE002","PZMA004","HGPC015","JGFE023","JKFC002",
    "DELF005","HHFA016","JCLE001","HHFA016","JJFJ001","QBFA007","BFGA427","HGPC015",
    "JGFC001","JDFA025","HMFC004","FCFA009","KDQA001","QEFA008","GHFA001","DELF013",
    "JKFA008","JJFC010","HGPC015","FAFA014","JJFC010","HHFA010","EDCA005","DELF005",
    "JCGE005","JCLE002","LMMC002","QZFA011","PAGA009","JKFA020","HMFC004","JGFC001",
    "NEKA020","FCFA029","JGFE023","JDFE002","HHFA025","HGPC015","HPPC003","JDFE001",
    "JGFE023","DELF005","JCGE001","HMFC004","JCGE001","HMFC004","JGFE023","AHPC001",
    "NEKA020","LFFA002","AHPA009","QBFA007","LMMC003","ZCJC001","JANE002","JHFA008",
    "LMMC002","MBCA006","HMFC004","HPPC003","NCCA017","FCFA009","HLFC002","KCFA008",
    "KDQA001","HHFA016","EZMA001","FCPA001","LHMA011","NEKA005","LMMC015","JCLE002",
    "ZCJC001","FCCA001","FCCA001","HHFA008","GGNC001","JKFA015","GAMA016","JGFE023",
    "DDQH009","NFKA008","NEKA010","HMQJ002","JAFA032","JHFA019","LHCA010","NBCA007",
    "NEKA020","JJFC009","QEMA006","QEFA008","QEMA013","QEFA008","JBNE004","JDFE001",
    "QEMA013","JANE005","MDFA002","NFKA007","JANE002","BFGA427","MCCA011","QZFA036",
    "BGMA002","HHFA008","KCMA001","JANE002","NEKA020","HPPC002","HKPA005","FCFA002",
    "HMFC004","JDJE001","JGFE023","JGFC001","HMFC004","QEFA008","JDFE002","QEFA020",
    "MACA001","DELF005","NBCA005","JKFA022","NEKA020","JCGE001","JGFA005","QBFA007",
    "HMFC004","QEGA001","JCLE002","HMFC004","HGFA005","GHFA001","KCFA008","GHFA001",
    "JRGA001","EJSA001","EZCA003","HHFA014","QZMA001","EBFA010","JCLE002","HKPA004",
    "DEEA001","HHFA025","JCGE001","HFCC003","JGFE023","HMFC004","JKFC002","JKFC006",
    "NCPA002","QAMA002","LMSA002","JKFA015","JGFE023","JGFC001","FCFA009","HCFA008",
    "QZFA014","JJFC006","NBCA010","JJFA010","JDFE001","MCPA005","NEKA014","HMFC004",
    "JGFC001","HPPC002","MEKA008","JKFA025","HHFA008","NEJA001","HMFC004","QEFA008",
    "PAGA011","EDCA004","NFPA003","JKFA020","JCGE001","JKFC001","JKFC003","JGFE023",
    "JGFE023","QEFA008","HMFC004","HPNC001","JJFC010","NFKA007","NEKA012","NEKA011",
    "HMFC004","HHFA016","HMFC004","JBFC001","HHFA010","QZJA011","GAMA018","HCFA008",
    "QAMA002","HHFA002","JJFC010","HHFA008","JCGE006","NFKA007","JCAE001","DELF005",
    "HHFA016","HHFA016","HHFA008","NZFA007","JCLE002","EBFA016","JKFA006","NFEC002",
    "EBFA016","JCAE001","JCGE001","GAMA007","LMMA012","MCCA010","JCGE006","JANE005",
    "DELF005","JDFE001","QZFA023","MCCA004","HFFC002","JCAE001","HMFC004","JDFE002",
    "HHFA025","JCGE006","JCAE001","JCAE001","JCGE006","HMFC004","DELF005","JCGE006",
    "DELF005","MCCA005","JCGE006","HMFC004","FCPA001","JJFC006","FCPA001","MEKA004",
    "MCCA005","NCCA017","FCFA009","FCFA009","JLCA005","GHFA001","MBCA005","PZMA004",
    "ZCJC001","MHDA005","FCCA001","HMFC004","NCCA019","QBFA003","GHFA002","MJEC002",
    "QZMA001","MBCA001","HMFC004","QEMA010","QZFA023","QEFA008","NFMC003","MCKA002",
    "JGFC001","BAFA008","NFKA007","LACA003","HHFA016","NBCA014","GHFA001","HHMA003",
    "JGFE023","NFKA008","JCLE002","FCPA001","FCCA001","NJEA003","CBMA002","JKFA024",
    "QZMA001","HMFC004","MEKA006","FCPA001","HGPC015","QZMA001","QBFA007","NEKA020",
    "HMFC004","JGFC001","QEFA008","QEFA008","QEFA008","NFMC003","JDFE002","QEKA001",
    "JGFE023","HMFC004","HHFA025","JLCA005","JGFA005","HMFC004","JKFA024","PDFA001",
    "LCJA003","JAFC005","JBNE004","QZFA036","HMFC004","LMMA004","GHFA001","KCFA008",
    "HCFA008","JRGA001","HMFC004","DEKA001","LHMH140","JKFA016","HMFC004","EDCA005",
    "FCPA001","HGPC015","NCCA017","QZMA001","JKFC005","NFKA007","JJFC003","NJEA002",
    "HHFA025","HGPC015","LMMA004","QEFA008","QZFA014","JMBA001","FCPA001","DELF013",
    "JGFA005","NGDA002","NFKA007","QZMA004","JGFE023","QZFA036","JDFE001","JCGE006",
    "JJFA007","NCCA007","JDFE001","LMMA009","KDQA001","HFFC018","FCPA001","FCFA009",
    "LMMC002","JGFE023","JCEE001","JLCA004","MZFA013","JHFA009","LAFA019","DGLF001",
    "NDPA014","DELF005","NZFA007","JCAD001","JAFA008","DELF014","JKFC001","NJEA003",
    "NCMA002","NBCA010","FAFA014","QEFA020","HHFA016","JGFE023","QEFA017","JDFE002",
    "JJFC003","EEAF006","QZFA002","NEKA020","HPPC003","JCGE001","GHFA001","KCFA008",
    "BFGA427","LDAA001","GFFC002","HFCC001","HMQJ001","JLCA007","MHJA001","NEKA017",
    "FCPA001","HJDC001","JANH798","EDFA007","FCCA001","EPLA002","JDFE001","JKFC001",
    "NFMC003","LDFA008","NEKA020","JJFA004","HMFC004","JANE002","JJFC010","JGFE023",
    "JGFA005","QEFA020","JANE005","PDFA001","JGFC001","EJGA002","NBCA010","HFFA008",
    "HMFC004","HHFA024","MCCA011","HHFA018","FCFA009","KDFC001","JJFJ001","HMFC004",
    "JGFE023","LMMA009","EEFA003","JGFE023","JDFE002","CAFA006","HPPC003","NBCA007",
    "NEKA020","LMMC002","HHFA016","FCCA001","QEFA008","NEKA020","FCPA001","JGFA005",
    "JJFC006","JDFE001","NEKA020","HHFA016","JGFE023","FAFA010","QEFA008","JGFE023",
    "QEEB152","JKFA018","JKFA015","MCCA011","JCGE006","NCCA002","JCAE001","HHFA025",
    "KDFC001","KDQA001","EZCA003","GFFA009","JJFC010","QZFA031","DELF007","NCCA017",
    "HFMC001","DELF005","FCFA016","QZJA011","QZFA036","NEKA020","EGFA003","NHFA001",
    "EGFA003","QZLA002","NFCC408","NEKA020","NFPA001","JCLD001","MJJA001","QEKA001",
    "JGFE023","JGFE023","FCCA001","QEFA020","HMFC004","JDFE001","NEKA006","LCJA003",
    "HHFA016","NEKA011","JDFA001","HJFA004","NEJA004","LFFA002","HMFC004","HMFC004",
    "LAFA024","CBPA002","PDFA002","FCPA001","DELF005","QBFA003","JJFC010","PAGA011",
    "NHMA002","HMFC004","GEFA002","HFFC017","JDFE002","LMMC002","JDFE001","FCCA001",
    "JDFE002","HGPC015","HPPC001","DELF014","JCGE001","DELF005","QEKA001","JCLE002",
    "JCEE001","HFFC018","GHFA001","FCFA009","BFGA427","LFAA002","HMFC004","JJFJ001",
    "HPPC003","HHFA016","LMMC015","LMFA002","FAFA014","FCPA001","DELF007","JCGE001",
    "JKFA027","JKFA020","JDFE001","EGFA003","HHFA016","JJFC004","HAMA027","AFCA001",
    "QEMA013","QZEA039","JKFC002","NBCA009","HGPC015","QZMA001","JANE002","QEKA001",
    "JKFA016","CBMD002","JCFA008","JKFA020","FCPA001","NBCA006","MCCA003","JKFC001",
    "PZMA004","JCLE002","HHFA025","NFFC002","HMFC004","NFMC003","QZJA011","FCCA001",
    "NEKA020","DELF005","FCPA001","HMFC004","QZMA001","LMMA010","MJEC002","DELF014",
    "JKFA022","JAFC005","JKFA022","LCJA003","MEKA006","JHFA006","NEKA011","NDCA003",
    "JJFA005","HMFC004","DELF015","DELF005","JGNE171","JCAD001","JAFC019","JCCC001",
    "HMFC004","HMFC004","ZCJA004","JCGE001","NFPA003","LFFA002","KCFA008","KDQA001",
    "HKPA007","JKFA022","LFAA001","DELF005","HHFA025","NEKA020","NEKA011","ZCQC002",
    "HMFC004","JDFE001","GGPA001","JFFC001","LMMC002","JCGE001","JCPD001","JKFC005",
    "QEMA012","HHFA025","GGJA001","NFKA007","HHFA016","HHFA016","QZMA001","MEKA008",
    "HHFA016","JCAE001","GHFA001","HHMA003","HFFC018","GHFA001","KDQA001","JGFE023",
    "LHMH454","DELF005","GEMA001","FCPA001","DELF005","FCCA001","JKFA027","JGFE023",
    "QZMA004","PAGA011","QZMA004","NEKA020","HMFC004","HDMA007","LMMA009","JAFC005",
    "JDFE002","GFFA013","JDFE002","JKFC006","JDFE002","JDFE001","JKFA022","JKFC005",
    "EEAF006","FCFA009","KDQA001","MBCA006","FCFA009","FCFA009","HPPC002","NBCA010",
    "DELF016","GBPA002","NEKA020","JKFA002","NEKA009","FCCA001","AHFA001","LMMC002",
    "HHFA016","JLFA003","NCCA017","FCFA011","NFFC004","JKFC001","JGFE023","QAPA002",
    "HMFC004","NFKA008","JGFE023","QEFA020","CAMA013","QEFA008","JGFE023","PZMA004",
    "KCFA001","JDFE001","JGFE023","JGNE171","JGNE171","NCCA011","HHFA016","HPPA002",
    "NBCA006","FCFA009","JKFA024","HEDA001","LFAA001","JANE002","JCLE002","HCFA012",
    "HHFA008","HCFA011","NEKA009","NFMC003","QEEB152","NJCA001","DELF005","DELF005",
    "JKFA020","JGFE023","PDFA001","HHFA016","JGFE023","EGFA003","JCPD001","PAGA011",
    "EGFA002","QEEB152","JKFC005","LFAA002","QAMA002","LMMA004","DELF005","NFMC003",
    "JGFE023","NEKA020","JDFE002","JDFE001","FCPA001","MCCA011","NEKA020","LHMH140",
    "AHPC001","JKFA024","QZJA011","JDJE001","JEMA023","HGPC015","HHFA025","HFFC002",
    "JCLE002","HPPC002","HHFA002","QZGA008","FCPA001","DEKA001","FCCA001","NFKA008",
    "QEFA020","HPPC002","JKFA027","QEKA001","MEKA006","QZMA001","PAGA009","HMFC004",
    "HHSA001","DELF005","QEGA003","JEFA009","QEFA008","JGFA005","JJFC006","FCPA001",
    "JCAE001","JBNE004","DELF005","GAMA013","JKDC001","JANE002","JBNE004","GAMA018",
    "NBCA007","HHFA025","NZFA010","FCFA009","HFFC018","KCFA008","KCFA008","ZCJC001",
    "JDFE002","MEKA005","LMMC015","HHFA002","EBFA016","DELF005","PAGA011","EDCA005",
    "LFAA001","HFFC002","JCLE002","EGFA003","QEKA001","QZEA039","AHPA014","JBNE004",
    "QEFA008","CBPA002","FCPA001","QEFA017","JDDB007","PCEA002","JCGE006","GFFC005",
    "HHFA016","JCLE002","LFAA002","AHPA017","JCLE002","NBCA009","LMMC020","QAMA002",
    "JCLD001","JCLE002","HMFC004","FCFA009","HHFA008","HCFA008","GGJC002","NBCA009",
    "NBPA005","NFFC002","QZMA001","GGPA001","JJFC003","QZFA023","QEFA017","NCCB006",
    "EZFA003","NBCA001","NEKA011","JCLE002","HHFA016","NBCA010","MEKA008","MJJA001",
    "NBCA003","HHFA008","FCFA009","LMMC015","JCLE002","JDDA006","QEGA003","NBGA007",
    "FCPA001","JEMA023","FCCA001","PDFA001","JJFC010","JDFE002","HMFC004","JANE005",
    "GAMA002","QZFA023","JKFC005","PAGA011","KDQA001","QEMA013","JGFE023","JDFE002",
    "QEFA008","QEFA020","JHFA008","JDFE001","FCCA001","DCMA001","FCPA001","JDFE001",
    "JGFC001","FCFA029","JJEC001","JJFA004","FAFA015","JDFE001","JCGE001","HHFA002",
    "HHFA025","MCCA005","JCLE002","HFFC018","GHFA001","JKFA027","LMMC015","KCFA005",
    "NBPA005","HHMC001","LAMA007","JDFE001","JGFE023","FCCA001","NCMA001","FCCA001",
    "NBCA006","HPPC001","JCFA010","QEGA003","EGFA003","QEKA001","QZMA004","JKDC001",
    "JKDC001","PAGA009","DELF005","JCLD001","HHFA009","JAFA003","HNFC002","CBPA002",
    "JJFC010","JKFC002","NEKA020","JKDC001","QZFA036","JGFC001","MFKA003","DELF005",
    "JDFA023","JAFC005","LCJA003","NBCA006","HHFA016","GHFA001","HHFA002","EDFA007",
    "FCFA009","HHFA002","LFAA002","KDFC001","KCFA008","JDFE002","HPPC002","GEMA001",
    "GBPE001","JGFA005","NBGA007","DELF007","JHEA007","HHFA016","JKFA022","JKFA022",
    "HHFA025","HKPA007","BAMA004","QZFA030","JAFC005","NFKA008","QZFA036","QEMA010",
    "QEFA020","JGFA005","LJFA004","JDGE001","GGNC001","JKDC001","MEKA008","JAFC005",
    "QZMA004","DELF005","HHFA025","NFPA003","JDJE001","NBCA009","HHFA027","GHFA001",
    "KCFA008","GHFA001","JLCA007","DELF005","JGFE023","JLDA002","HPPC002","DELF014",
    "QZFA004","NGDA002","EJSA001","JCGE006","HKPA007","JJFC010","PAGA011","GAMA018",
    "NEKA020","JGFE023","JGFE023","JDFE001","JDFE001","JJCC003","BFGA427","JGNE171",
    "MEKA008","HHFA025","JKFC001","JGFC001","HHCC001","HHFA002","GHFA001","LDFA008",
    "AHEA012","NJMA003","JGFE365","EZMA001","DELF005","NBCA006","JKFA015","HPPC001",
    "HPPC002","BAFA006","MEKA008","GGNC001","NFFC002","QZGA008","DELF005","QEKA001",
    "NEKA011","HHFA008","QEKA001","HGFC016","JCCA006","QEFA008","JGFC001","FCCA001",
    "FCPA001","JJFC010","JCAE001","JKFC005","DELF014","NEKA020","LACA003","QEMA013",
    "JCLD001","FCFA002","JKFC001","HMFC004","HMFC004","HGPC015","LFAA002","LLMC004",
    "KDFC001","GHFA001","JRGA001","JCAE001","NFKA008","HPPC002","FCPA001","DELF005",
    "EDFA007","JCGE006","JJFC010","JCGE006","HKPA007","JKFA020","QAMA002","NFMC003",
    "EEAF006","HAMA010","DELF005","NEKA020","HMFC004","LMMC015","QEFA008","JGFA005",
    "QEFA017","JGFC001","JCEE001","FCCA001","JANE005","JJFC010","JDFE002","HFMC008",
    "HPNA001","CAMA022","JCAE001","NDPA002","NGPA001","JKFC001","HMFC004","JGFE023",
    "LCJA003","JDFE001","NBCA009","GHFA001","MCCA001","AHPA017","GAMA016","JJCC001",
    "NEKA020","HHFA016","MJFA002","FCFC001","FCCA001","HFCC001","DELF005","NCCA017",
    "HMFC004","JANE005","JGFE023","NFKA008","LFAA001","MACA001","QZFA031","HMFC004",
    "NFEC002","FCPA001","QZFA014","JJFC010","JKFC002","JCAE001","FCFA029","HHFA016",
    "JKFC005","LCJA003","NEKA011","NFMC003","JCLE002","JDPE002","JGFE023","JCAE001",
    "DELF005","MCCA001","HMFC004","HHFA008","LMMC001","JJFC010","JDDB007","HHFA025",
    "HHFA025","LMMC001","EEAF006","JCGE001","FCCA001","JGFC001","JDFE001","JANE002",
    "JGFC001","JJCC001","JCGE001","JDFE002","QEFA007","HGFA005","HHFA025","NEKA020",
    "JCAE001","KCFA008","GHFA001","HFFC018","JKFA027","KCFA008","HGPC015","JDFE002",
    "LFAA002","LFFA002","CBFA002","HMFC004","LMMC002","EBFA016","JKFA015","JJFC010",
    "JDFE001","JCGE001","HMFC004","GBPE001","NBMA003","QZMA001","NBCA014","NEKA017",
    "JAFC001","QEFA008","FAFA014","QEFA008","JJFC008","GBBA002","FCCA001","QEFA017",
    "FCPA001","JKFC001","JGFC001","JJFC003","MDCA011","AHPC001","NBCA006","HFCC001",
    "HGPC015","QBFA004","HHMA002","HHMA003","KDQA001","KCFA004","CBFA007","JKFA025",
    "JKFC001","QZMA005","QEGA004","DELF005","DELF005","EBFA016","JKFC005","LMMA010",
    "JANE002","JANE005","EGFA003","QEMA006","QEFA020","NEKA020","HPPC003","KEFC002",
    "FAFA014","QEFA020","JGFE023","PZMA004","JGFE023","JCGE001","ZCJC001","DELF016",
    "HPNC001","JGFE023","JCLE002","NEKA020","LMMA012","JCLE002","NCCA002","NJMA003",
    "HHFA016","FCFA009","ZCQA001","GHFA001","JDFE002","KCFA005","LHFA001","JJFC010",
    "DELF005","LMMC002","EBCA008","JDFE003","JCKE002","JGFE023","LMMA004","JDFE001",
    "EGFA003","HKPA007","HPPA003","NCPA002","FCFC004","QZMA001","LFAA002","QEFA002",
    "DELF016","DELF005","JGFA005","GHFA001","QEFA008","QEFA008","JDPE002","JGFC001",
    "PZMA004","HPPC001","JJFC010","JGFA005","JKFC006","JAFC005","NCCA017","JCLE002",
    "HHFA025","FCFA009","QZMA001","JCAE001","NEKA011","NCCA018","NCCA004","FCFA014",
    "JDFA004","MCCA011","JJFC010","JCAE001","JCAE001","HMFC004","DELF015","PDFA002",
    "FCPA001","JJFC010","AHCA022","JDFE001","JCGE006","MEKA008","QZFA014","JKFC001",
    "JCAE001","NEKA020","JKFA027","KDQA001","HHFA002","FCFA009","JDFE001","FCPA001",
    "JGFC001","JGFE023","JCAE001","FCCA001","JDFE002","JKFC002","HPPC002","JCAE001",
    "ZCJC001","QZFA004","LMMA012","NBCA010","DELF005","JCAE001","QZMA004","JJFA010",
    "KCFA008","KDFC001","FCFA009","GHFA001","NFKA008","JDFE001","FCPA001","JKFA027",
    "JKFA015","ZCQC002","JDFE001","JDFE001","QEMA004","JGFE023","JKFA027","NEKA020",
    "NEKA011","QZMA005","JCAE001","NEKA020","JGFE023","GHFA001","HHFA002","JJFC010",
    "NEKA011","FCPA001","JGFC001","JKFA020","JAFC001","JCLE002","NACA004","HMFC004",
    "JGFC001","QEFA017","JCAE001","NDCA003","JCGE006","MEKA008","HMFC004","KCFA008",
    "HHFA002","GHFA001","GHFA001","HHFA016","LMMC002","FCFA009","LFAA002","DELF005",
    "QEFA020","FCPA001","FCPA001","NCCB001","JCLE002","JDFA001","JGFA005","NFKA008",
    "JCGE006","JDFE001","GHFA002","BAMA005","NEKA020","LMMA004","JANE002","HMFC004",
    "JCAE001","JGFA005","FCPA001","FCCA001","QEFA008","NEKA011","JCGE001","JDFE001",
    "JDFE002","JGFE023","JJFA010","JJFA007","HGPC015","DELF005","NCCA017","JHEA010",
    "HHFA025","HMQJ001","HHFA025","HHFA025","KCFA005","HFFC018","LLMC004","KCFA005",
    "HPPC003","JGFE023","JDFE001","JDPE002","JGFE023","FAFA014","QZMA004","JCGE005",
    "DELF005","EDFA007","JKFA005","DELF007","JANE005","JGFE023","GAMA018","NFKA002",
    "JJFC006","QAMA002","JLFA003","HHFA016","JGFC001","GHFA001","KDQA001","JCGE001",
    "KDFC001","JJFC010","JGFC001","JDCA003","JCAE001","ZCJC001","NEKA020","LMMA012",
    "JFFC001","KDQA001","NFPA003","JCGE001","HMFC004","GAME001","KCFA005","DELF013",
    "NEKA020","LFAA001","JKFA031","JGFC001","LFAA001","LFAA001","JJFJ001","NCPA015",
    "NJEA002","JANE002","KCFA001","JGFE023","FCFA009","JGFE023","JJFC010","JCGE005",
    "JGFE023","JGFC001","HKPA005","JGFE023","NEKA020","HKPA005","NCCA012","NEKA020",
    "JGFC001","GHFA001","HJFA004","MEKA008","GHFA001","HGCA006","GBPE001","GAMA007",
    "HFFC001","JGFE365","QEKA001","MCCA010","JDFE001","HMFC004","JJFC010","JCGE006",
    "JKFA020","JJFC003","JCGE001","HMGE002","HMLE003","AMQP012","HHFE002","JVJF002",
    "DDAF008","AMQP012","HHSE002","AMQP012","AMQP012","DHPF002","DDPF002","DEPF033",
    "DDAF007","HHFE002","AMQP012","EEAF006","DDAF010","AMQP012","DDQH009","HHSE002",
    "DEPF033","HBMA006","EEAF006","DDAF008","DDAF008","AMQP012","DDQH009","HBMA006",
    "AMQP012","JKNE001","LBLD026","DEPF012","DDAF008","AMQP012","DDQH009","DDAF008",
    "AMQP012","DEPF010","DEPF033","HMQH003","AMQP012","HBMA006","EDAF007","DEPF033",
    "DDAF007","EDSF014","DDAF008","EEAF006","EBLA003","EDAF001","DDQH009","EDSF009",
    "AMQP012","DELF017","LBLD038","HHFE002","HBMA006","DEPF033","HMLE002","DEPF005",
    "DENF018","HBGD420","DEPF033","DDAF008","DASF005","LBLD025","AMQP012","AMQP012",
    "AMQP012","DDQH009","DDAF010","DEPF033","DEPF033","DDAF008","DDAF008","DEPF033",
    "DEPF033","DEPF010","JEPE002","HMLE002","DEPF033","DDAF010","DEQF005","EDAF001",
    "EEAF006","AMQP012","DDAF008","HGQE001","LBLD010","DENF018","DDQH009","DDPF002",
    "EDAF003","AMQP012","AMQP012","HMLE002","LBLD038","DDQH009","DEPF033","EDAF003",
    "EEPF001","DEPF033","LBFA023","DENF015","DEPF033","JKNE001","DDAF008","DDAF008",
    "DDAF010","HHFE006","HHFE002","EDAF007","HGQE003","DEPF033","DENF021","EDAF003",
    "DEPF033","DEPF033","AMQP012","AMQP012","HLNM001","DEPF033","LBFA023","DENF035",
    "HBMA006","DDQH009","DDAF008","JBQE001","AMQP012","EDAF003","EDAF003","AMQP012",
    "DEPF033","JKFE001","DEPF033","DEPF033","DDAF008","HMLE002","HMGE002","AMQP012",
    "HMLE002","DDAF008","HHFE004","DENF035","DDPF002","DENF018","HMLE002","DEQF001",
    "EBLA003","DDPF002","HGLE001","EDAF005","AMQP012","HHFE004","DENF035","DENF035",
    "JEGE003","DDQH009","DEPF033","AMQP012","DDAF010","JDQE003","DDAF008","DDQH009",
    "HMLE002","HBMA006","DEPF033","AMQP012","DDAF008","DEPF033","DEPF033","DEPF033",
    "HHFE006","EEAF006","AMQP012","EEAF006","HHSE002","DEPF033","JEPE002","JKNE001",
    "DDQH009","DEPF033","DDAF007","EEAF006","JEFE004","AMQP012","JDQE001","HBMA006",
    "DEPF033","EEAF006","DDAF010","DDAF008","AMQP012","DEQF001","DEQF001","DDAF010",
    "HMGE002","DEPF033","DDAF008","EBLA003","LBLD013","DEPF033","DEPF010","DEPF012",
    "HMGE002","DEPF033","DDAF007","HMGE002","HMGE002","DDAF010","DEPF033","DDAF008",
    "LBLD026","JBQE001","DEPF033","DEPF033","HESE002","DEPF033","HHFE002","DDAF008",
    "DDAF008","DEPF006","HBMA006","HBMA006","DEPF033","DDAF008","HLNM001","DEPF033",
    "DDAF008","EEAF006","DDAF010","HBMA006","DDAF010","DEPF033","JELE003","DDAF001",
    "JVJF005","DDAF007","AMQP012","DDQH009","HBMA006","JKNE001","DDAF008","HMLE002",
    "HMLE002","HLNM001","HBGD021","DDQH009","JEPE002","HMQJ001","LBLD026","DEPF033",
    "DDQH009","DEPF033","DDQH009","AMQP012","DDAF008","DDAF008","DDAF008","EEAF006",
    "DDAF008","DEPF033","DDQH009","DEPF033","EDSF016","EEPF002","EEPF002","DEPF033",
    "DDAF008","HHFE002","DEPF033","AMQP012","EZPF004","EDSF016","DEPF005","DENF035",
    "HBMA006","DDAF008","HHSE002","DEPF033","DEPF033","DDPF002","DEPF033","DDQH009",
    "DEPF010","DEPF033","AMQP012","DDAF008","AMQP012","JKNE001","EEPF002","DEPF033",
    "EDSF016","HBMA006","DDAF008","DDAF010","DDAF008","HMLE002","DASF005","DEPF033",
    "HHFE002","AMQP012","EEAF006","AMQP012","DEPF033","HBMA006","DDQH009","HLNM001",
    "DEPF033","EDSF016","EDSF004","EDLF005","HBMA006","HHSE002","DEPF033","LBLD025",
    "LBLD010","DDAF008","DDAF008","DEPF033","HHFE006","DEPF033","AMQP012","EDSF004",
    "EDSF004","DAGF001","DEPF033","DDAF008","DEPF033","AMQP012","DDQH009","DDQH009",
    "EDSF004","EDSF004","EDSF004","HBMA006","HHFE002","DDPF002","DEPF033","DEPF033",
    "DDAF007","DEPF033","DEPF033","EDSF004","EDSF004","DEPF033","EDAF003","DEPF033",
    "HBMA006","DEPF033","DENF035","DDAF008","DDQH013","DDAF008","DDQH009","EDSF004",
    "EZPF004","EDSF004","DDQH009","EDSF004","EESF007","DENF018","DEPF004","DEPF033",
    "DEPF033","EDSF004","DEQF004","AMQP012","HHSE002","EDSF004","AMQP012","DDAF008",
    "LBLD026","DEPF033","HBMA006","DEPF033","EDSF006","HMLE002","DDPF002","DEPF033",
    "EEAF006","HMLE003","AMQP012","EBLA003","EDSF004","EDSF004","EEAF006","AMQP012",
    "DDQH009","EDSF004","EDSF004","EDSF006","HHFE004","DEPF033","AMQP012","AMQP012",
    "DDAF010","DDPF002","HMQH003","DDPF002","EAJF341","DDAF008","DDAF008","DDAF008",
    "EDSF004","DDPF002","EDSF004","DEEF001","DDAF008","DENF018","HHFE006","JEPE002",
    "DEPF033","DEPF033","HHSE002","EDSF004","EGSF001","EDSF004","EDSF004","DDAF008",
    "DEPF033","DEPF033","DASF074","EDSF004","DGPF002","DDAF007","DDAF008","EEAF006",
    "HMLE002","EEAF006","EDSF004","DDAF008","EDSF004","DEPF033","DDAF008","EDSF004",
    "JVJF008","DENF035","DDAF010","HMGE001","EDSF004","EDSF004","EDSF004","EDSF004",
    "EEAF006","HBMA006","DEPF033","DENF018","DEPF033","DEPF033","DEEF001","EDSF004",
    "ECSF004","DEPF033","LBLD010","DEPF033","DEPF033","DDAF008","DEPF033","DEPF033",
    "DDAF008","EDSF004","EDSF004","EDSF004","DEPF012","EDSF004","HMLE002","DEPF033",
    "DEPF010","EDSF004","EDSF004","HMLE002","EDSF004","DEPF033","DEPF006","HEFE003",
    "DDQH009","DDQH009","EDSF004","EDSF004","DDAF007","DDAF008","DEPF006","DEPF012",
    "EPLF005","HMGE002","DDQH009","DDQH009","EDSF004","EDSF004","EBLA003","DDAF008",
    "JEPE002","DDAF008","EEPF001","EEAF006","EEAF006","DEPF033","DEPF012","JVJF008",
    "DEPF033","DDQH013","EPLF004","DEPF033","JELE003","DEPF033","HBMA006","DEPF033",
    "DDAF008","EDSF004","AMQP012","DDQH009","DDAF008","EBLA003","DEPF006","DENF035",
    "EDSF004","EDSF016","DDAF007","DEPF033","DEPF010","HGQE001","EDSF004","EDSF004",
    "EEAF006","EDSF004","AMQP012","DDAF008","EDAF001","EDAF003","HBMA006","DEPF033",
    "DENF035","HBMA006","HBMA006","DDAF008","HBMA006","DDAF008","DDAF008","EEAF004",
    "DEPF012","EDSF004","DDQH009","DEPF033","HGQE001","DEPF033","DEPF033","DDAF008",
    "EDSF004","DEPF033","DEPF033","HBMA006","EGSF001","EEAF002","JKQE001","DDAF008",
    "HBMA006","DEPF033","DDAF008","HMGE002","DEPF033","DEPF033","HGSE001","DHSF001",
    "LHMH002","DDQH009","DDPF002","HMLE002","DEPF033","DEPF033","DEPF033","DEPF033",
    "AMQP012","EDSF004","DDAF008","EEAF006","DEPF033","HMGE002","DEPF010","EGSF001",
    "DDAF008","HMLE002","DDAF008","EDSF004","EDSF004","AMQP012","DDAF008","DEPF033",
    "DEPF033","JEPE002","EDSF004","EBLA003","JCGE004","DEPF033","EDSF004","EDSF004",
    "DDAF008","EDSF004","LBLD010","DEPF033","HBMA006","EDSF004"
]

print(f"✅ {len(LISTE_ACTES_AUTORISES)} codes CCAM autorisés")

# ============================================================================
# MAPPINGS SPÉCIALITÉS
# ============================================================================

CATEGORIE_DICT = {
    'Chirurgie digestive': 'Digestif',
    'Chirurgie générale': 'Digestif',
    'Gastroentérologie': 'Digestif',
    'Chirurgie orthopédique et traumatologique': 'Orthopédique',
    'Orthopédie': 'Orthopédique',
    'Chirurgie vasculaire': 'Vasculaire',
    'Chirurgie cardiaque': 'Vasculaire',
    'Cardiologie': 'Vasculaire',
    'Chirurgie thoracique et cardiovasculaire': 'Vasculaire',
    'Urologie': 'Urologue',
    'Gynécologie-Obstétrique': 'Gynéco',
    'Gynécologie-obstétrique': 'Gynéco',
    'ORL et chirurgie cervico-faciale': 'ORL',
    'Oto-rhino-laryngologie (ORL)': 'ORL',
    'Ophtalmologie': 'Ophtalmo',
    'Chirurgie maxillo-faciale et stomatologie': 'Stomatologie',
    'Odontologie': 'Stomatologie',
    'Stomatologie': 'Stomatologie',
    'Chirurgie plastique': 'Plasticien',
    'Chirurgie de la main': 'Plasticien',
    'Chirurgie du rachis': 'Orthopédique',
    'Chirurgie thoracique': 'Vasculaire',
    'Neurochirurgie': 'Neuro',
    'Dermatologie': 'Dermato',
}

AGE_PAR_SPECIALITE = {
    'Chirurgie digestive': (30, 75),
    'Gynécologie-obstétrique': (18, 45),
    'Neurochirurgie': (25, 70),
    'ORL et chirurgie cervico-faciale': (3, 65),
    'Ophtalmologie': (50, 85),
    'Chirurgie orthopédique et traumatologique': (40, 80),
    'Chirurgie plastique': (20, 70),
    'Stomatologie': (15, 60),
    'Urologie': (45, 80),
    'Chirurgie vasculaire': (50, 85)
}

PROBA_HOMME_PAR_SPECIALITE = {
    'Chirurgie digestive': 0.55,
    'Gynécologie-obstétrique': 0.02,
    'Neurochirurgie': 0.60,
    'ORL et chirurgie cervico-faciale': 0.50,
    'Ophtalmologie': 0.50,
    'Chirurgie orthopédique et traumatologique': 0.55,
    'Chirurgie plastique': 0.35,
    'Stomatologie': 0.50,
    'Urologie': 0.90,
    'Chirurgie vasculaire': 0.70
}

DP_PAR_SPECIALITE = {
    'Chirurgie digestive': ['K35','K40','K42','K80','K81','K56','K57','K64','C18','C20','K25','K26'],
    'Gynécologie-obstétrique': ['O80','O81','O82','N81','N92','D25','N97','O34','O60','Z30'],
    'Neurochirurgie': ['G93','I61','I60','S06','G95','C71','D33','M50','M51','G40'],
    'ORL et chirurgie cervico-faciale': ['J35','J34','J32','H90','C32','C10','J38','H61','H66','H81'],
    'Ophtalmologie': ['H25','H26','H33','H40','H35','H02','H05','H04','H11','H53'],
    'Chirurgie orthopédique et traumatologique': ['M16','M17','M19','S72','S82','M51','M47','M23','M75','S42'],
    'Chirurgie plastique': ['L90','L91','C44','T20','T21','T22','Q18','N64','Q35','Q36'],
    'Stomatologie': ['K04','K05','K07','K10','K08','C03','C04','K06','K09','S02'],
    'Urologie': ['N20','N13','C61','N40','N32','C67','N39','N31','N28','R31'],
    'Chirurgie vasculaire': ['I70','I71','I72','I80','I83','I65','I74','I77','I87','E11'],
}

# ============================================================================
# STRUCTURES DE DONNÉES
# ============================================================================

@dataclass
class Patient:
    id: int
    age: int
    sexe: int
    ccam: str
    dp: str
    duree_sejour_predite: float
    duree_op: float
    specialite: str

@dataclass
class Operation:
    id_op: int
    duree_op: float
    duree_rum: float
    spe_rss: List[str]
    medecin: Optional[int] = None
    salle: Optional[int] = None
    jour: Optional[int] = None

class Solution:
    def __init__(self, operations: List[Operation], config: dict):
        self.operations = operations
        self.config = config
        self.cout = float('inf')
        
    def copy(self):
        return Solution([copy.deepcopy(op) for op in self.operations], self.config.copy())

# ============================================================================
# MODÈLES PYDANTIC
# ============================================================================

class HospitalConfig(BaseModel):
    nb_lits: int = 100
    nb_salles: int = 6
    t_max_salle: float = 9.0
    t_max_medecin: float = 8.0
    capacite_weekend: float = 0.5
    date_debut: str = "2026-01-01"
    date_fin: str = "2026-12-31"
    medecins: List[Dict] = [
        {"specialite": "Chirurgie digestive", "nombre": 7, "duree_moyenne": 150},
        {"specialite": "Gynécologie-obstétrique", "nombre": 3, "duree_moyenne": 80},
        {"specialite": "Neurochirurgie", "nombre": 1, "duree_moyenne": 135},
        {"specialite": "ORL et chirurgie cervico-faciale", "nombre": 2, "duree_moyenne": 130},
        {"specialite": "Ophtalmologie", "nombre": 1, "duree_moyenne": 110},
        {"specialite": "Chirurgie orthopédique et traumatologique", "nombre": 8, "duree_moyenne": 150},
        {"specialite": "Chirurgie plastique", "nombre": 1, "duree_moyenne": 158},
        {"specialite": "Stomatologie", "nombre": 3, "duree_moyenne": 160},
        {"specialite": "Urologie", "nombre": 5, "duree_moyenne": 90},
        {"specialite": "Chirurgie vasculaire", "nombre": 5, "duree_moyenne": 145},
    ]

class AlgoParams(BaseModel):
    algo_type: str = "genetic"
    taille_population: int = 20
    nb_generations: int = 50
    taux_mutation: float = 0.2
    taux_elitisme: float = 0.1
    t_init: float = 100.0
    t_min: float = 0.1
    alpha: float = 0.9
    max_iter: int = 25

class OptimizationRequest(BaseModel):
    nb_patients: int
    hospital_config: HospitalConfig
    algo_params: AlgoParams

# ============================================================================
# GÉNÉRATION INTELLIGENTE DES PATIENTS
# ============================================================================

def generer_patients_intelligents(nb_patients: int) -> pd.DataFrame:
    """Génère patients de manière réaliste"""
    actes_valides = [acte for acte in LISTE_ACTES_AUTORISES if acte in CCAM_TO_SPE]
    
    if not actes_valides:
        raise RuntimeError("Aucun acte CCAM valide trouvé dans la BDD")
    
    data = []
    for i in range(nb_patients):
        acte = random.choice(actes_valides)
        spec = CCAM_TO_SPE.get(acte, 'Chirurgie digestive')
        age_min, age_max = AGE_PAR_SPECIALITE.get(spec, (30, 75))
        age = random.randint(age_min, age_max)
        p_homme = PROBA_HOMME_PAR_SPECIALITE.get(spec, 0.5)
        sexe = 1 if random.random() < p_homme else 2
        dp_choices = DP_PAR_SPECIALITE.get(spec, ['K35'])
        dp = random.choice(dp_choices)
        
        data.append({
            'age': age,
            'sexe': sexe,
            'acte_ccam': acte,
            'dp': dp
        })
    
    return pd.DataFrame(data)

# ============================================================================
# PRÉDICTION DURÉE DE SÉJOUR
# ============================================================================

def predire_duree_sejour(df_patients: pd.DataFrame) -> pd.DataFrame:
    """Prédit la durée de séjour via le modèle ML"""
    if classifier is None:
        raise HTTPException(status_code=500, detail="Modèle ML non chargé")
    
    df = df_patients.copy()
    
    for col in feature_cols:
        if col not in df.columns:
            df[col] = 0
    
    X = df[feature_cols].fillna(0)
    classes_predites = classifier.predict(X)
    df["classe_predite"] = classes_predites
    
    durees = []
    for idx, row in df.iterrows():
        classe_texte = str(row["classe_predite"])
        
        if classe_texte in regressors and regressors[classe_texte] is not None:
            X_row_df = pd.DataFrame([X.iloc[idx]], columns=X.columns)
            X_scaled = scalers[classe_texte].transform(X_row_df)
            duree = regressors[classe_texte].predict(X_scaled)[0]
            durees.append(max(1, float(duree)))
        else:
            duree_defaut = {"Court": 2.0, "Moyen": 5.0, "Long": 10.0}.get(classe_texte, 5.0)
            durees.append(duree_defaut)
    
    df["duree_sejour_predite"] = durees
    return df


# ============================================================================
# ALGORITHME GÉNÉTIQUE V2 (VERSION PERFORMANTE - INSPIRÉ TON AMI)
# ============================================================================

class AlgorithmeGenetiqueV2:
    def __init__(self, patients: List[Patient], config: HospitalConfig, params: AlgoParams):
        self.patients = patients
        self.config = config
        self.params = params
        self.nb_salles = config.nb_salles
        self.nb_lits = config.nb_lits
        self.t_max_salle = config.t_max_salle * 60
        self.t_max_medecin = config.t_max_medecin * 60
        self.capacite_weekend = config.capacite_weekend
        
        date_debut = datetime.strptime(config.date_debut, "%Y-%m-%d")
        date_fin = datetime.strptime(config.date_fin, "%Y-%m-%d")
        self.nb_jours_max = (date_fin - date_debut).days
        self.date_debut = date_debut
        
        self.medecins_par_spe = {}
        for m in config.medecins:
            self.medecins_par_spe[m["specialite"]] = m["nombre"]
    
    def _est_periode_reduite(self, jour: int) -> bool:
        """Vérifie si weekend OU vacances scolaires"""
        date = self.date_debut + timedelta(days=jour)
        return date.weekday() >= 5 or est_vacances(date)
    
    def _generer_solution_initiale(self) -> Solution:
        """Génère solution répartie uniformément"""
        operations = []
        nb_patients = len(self.patients)
        espacement = max(1, self.nb_jours_max // nb_patients)
        
        for idx, patient in enumerate(self.patients):
            jour_initial = (idx * espacement) % self.nb_jours_max
            op = Operation(
                id_op=patient.id,
                duree_op=patient.duree_op,
                duree_rum=patient.duree_sejour_predite,
                spe_rss=[patient.specialite]
            )
            op.jour = jour_initial
            operations.append(op)
        
        solution = Solution(operations, self.config.dict())
        self._affecter_ressources(solution)
        return solution
    
    def _affecter_ressources(self, solution: Solution):
        """Affecte ressources avec priorité début période"""
        for op in solution.operations:
            if op.jour is None or op.jour >= self.nb_jours_max:
                op.jour = random.randint(0, min(30, self.nb_jours_max - 1))
            op.medecin = None
            op.salle = None
        
        operations_triees = sorted(solution.operations, key=lambda x: x.jour or 0)
        occupation_medecins = defaultdict(lambda: defaultdict(float))
        occupation_salles = defaultdict(lambda: defaultdict(float))
        lits_occupes = defaultdict(int)
        
        for op in operations_triees:
            planifie = False
            specialite = op.spe_rss[0] if op.spe_rss else "Autre"
            nb_medecins = self.medecins_par_spe.get(specialite, 1)
            jour_prefere = op.jour or 0
            
            # Stratégie : Essayer autour du jour préféré
            for rayon in [7, 30, self.nb_jours_max]:
                debut = max(0, jour_prefere - rayon)
                fin = min(self.nb_jours_max, jour_prefere + rayon)
                jours_a_tester = list(range(debut, fin))
                random.shuffle(jours_a_tester)
                
                for jour_test in jours_a_tester:
                    # Éviter week-end/vacances si possible
                    if self._est_periode_reduite(jour_test) and rayon < 30:
                        continue
                    
                    periode_reduite = self._est_periode_reduite(jour_test)
                    capacite = self.capacite_weekend if periode_reduite else 1.0
                    t_max_salle_jour = self.t_max_salle * capacite
                    t_max_medecin_jour = self.t_max_medecin * capacite
                    
                    try:
                        duree_rum_jours = max(1, int(float(op.duree_rum)))
                    except:
                        duree_rum_jours = 3
                    
                    lits_requis = duree_rum_jours + 1
                    
                    if lits_occupes[jour_test] + lits_requis > self.nb_lits:
                        continue
                    
                    # Trouver médecin
                    medecin_trouve = None
                    for m in range(nb_medecins):
                        if occupation_medecins[jour_test][m] + op.duree_op <= t_max_medecin_jour:
                            medecin_trouve = m
                            break
                    
                    if medecin_trouve is None:
                        continue
                    
                    # Trouver salle
                    salle_trouvee = None
                    if specialite in ["Neurochirurgie", "Chirurgie orthopédique et traumatologique"]:
                        salle_test = self.nb_salles - 1
                        if occupation_salles[jour_test][salle_test] + op.duree_op <= t_max_salle_jour:
                            salle_trouvee = salle_test
                    else:
                        for s in range(self.nb_salles - 1):
                            if occupation_salles[jour_test][s] + op.duree_op <= t_max_salle_jour:
                                salle_trouvee = s
                                break
                    
                    if salle_trouvee is not None:
                        op.jour = jour_test
                        op.medecin = medecin_trouve
                        op.salle = salle_trouvee
                        occupation_medecins[jour_test][medecin_trouve] += op.duree_op
                        occupation_salles[jour_test][salle_trouvee] += op.duree_op
                        
                        for d in range(lits_requis):
                            if jour_test + d < self.nb_jours_max:
                                lits_occupes[jour_test + d] += 1
                        
                        planifie = True
                        break
                
                if planifie:
                    break
    
    def _calculer_cout(self, solution: Solution) -> float:
        """Fonction coût multi-critères (6 critères)"""
        nb_non_planifies = sum(1 for op in solution.operations if op.jour is None)
        
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                operations_par_jour[op.jour] += 1
                for d in range(duree_rum):
                    if op.jour + d < self.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        # 1. RMSD
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations))
        else:
            rmsd = 0
        
        # 2. Variation totale (pénalise changements brusques)
        tv = 0
        lits_arr = [lits_par_jour.get(j, 0) for j in range(self.nb_jours_max)]
        for i in range(1, len(lits_arr)):
            tv += abs(lits_arr[i] - lits_arr[i-1])
        
        # 3. Pénalité dernier jour
        if lits_par_jour:
            dernier_jour = max(k for k, v in lits_par_jour.items() if v > 0)
            penalite_dernier_jour = lits_par_jour[dernier_jour]
        else:
            penalite_dernier_jour = 0
        
        # 4. Concentration opérations
        nb_ops = list(operations_par_jour.values())
        if nb_ops:
            max_ops_jour = max(nb_ops)
            penalite_concentration = max_ops_jour
        else:
            penalite_concentration = 0
        
        # Normalisation et pondération
        max_TV = self.nb_jours_max * self.nb_salles
        max_RMSD = self.nb_lits
        max_lits_last = self.nb_lits
        max_non_affectees = len(solution.operations)
        
        cout_total = (
            (65 / max(max_TV, 1)) * tv +
            (35 / max(max_RMSD, 1)) * rmsd +
            (20 / max(max_lits_last, 1)) * penalite_dernier_jour +
            (150 / max(max_non_affectees, 1)) * nb_non_planifies +
            (10 / max(max_ops_jour if nb_ops else 1, 1)) * penalite_concentration
        )
        
        solution.cout = cout_total
        return cout_total
    
    def _selection(self, population: List[Solution]) -> Solution:
        """Sélection par tournoi"""
        tournoi = random.sample(population, min(3, len(population)))
        return min(tournoi, key=lambda s: s.cout)
    
    def _croisement(self, parent1: Solution, parent2: Solution) -> Solution:
        """Croisement à un point"""
        enfant = Solution([copy.deepcopy(op) for op in parent1.operations], parent1.config)
        point_croisement = random.randint(0, len(enfant.operations))
        
        for i in range(point_croisement, len(enfant.operations)):
            if parent2.operations[i].jour is not None:
                enfant.operations[i].jour = parent2.operations[i].jour
        
        self._affecter_ressources(enfant)
        return enfant
    
    def _mutation(self, solution: Solution):
        """Mutation par décalage temporel"""
        for op in solution.operations:
            if random.random() < self.params.taux_mutation:
                if op.jour is not None:
                    decalage = random.randint(-10, 10)
                    op.jour = max(0, min(self.nb_jours_max - 1, op.jour + decalage))
        
        self._affecter_ressources(solution)
    
    def optimiser(self) -> Solution:
        """Exécute l'algorithme génétique"""
        population = []
        for _ in range(self.params.taille_population):
            sol = self._generer_solution_initiale()
            self._calculer_cout(sol)
            population.append(sol)
        
        meilleure_solution = min(population, key=lambda s: s.cout)
        
        for gen in range(self.params.nb_generations):
            population_triee = sorted(population, key=lambda s: s.cout)
            nb_elites = int(self.params.taille_population * self.params.taux_elitisme)
            nouvelle_population = population_triee[:nb_elites]
            
            while len(nouvelle_population) < self.params.taille_population:
                parent1 = self._selection(population)
                parent2 = self._selection(population)
                enfant = self._croisement(parent1, parent2)
                self._mutation(enfant)
                self._calculer_cout(enfant)
                nouvelle_population.append(enfant)
            
            population = nouvelle_population
            meilleure = min(population, key=lambda s: s.cout)
            
            if meilleure.cout < meilleure_solution.cout:
                meilleure_solution = meilleure
        
        return meilleure_solution

# ============================================================================
# RECUIT SIMULÉ V2 (VERSION PERFORMANTE - INSPIRÉ TON AMI)
# ============================================================================

class RecuitSimuleV2:
    def __init__(self, patients: List[Patient], config: HospitalConfig, params: AlgoParams):
        self.patients = patients
        self.config = config
        self.params = params
        self.nb_salles = config.nb_salles
        self.nb_lits = config.nb_lits
        self.t_max_salle = config.t_max_salle * 60
        self.t_max_medecin = config.t_max_medecin * 60
        self.capacite_weekend = config.capacite_weekend
        
        date_debut = datetime.strptime(config.date_debut, "%Y-%m-%d")
        date_fin = datetime.strptime(config.date_fin, "%Y-%m-%d")
        self.nb_jours_max = (date_fin - date_debut).days
        self.date_debut = date_debut
        
        self.medecins_par_spe = {}
        for m in config.medecins:
            self.medecins_par_spe[m["specialite"]] = m["nombre"]
    
    def _est_periode_reduite(self, jour: int) -> bool:
        date = self.date_debut + timedelta(days=jour)
        return date.weekday() >= 5 or est_vacances(date)
    
    def _generer_solution_initiale(self) -> Solution:
        operations = []
        nb_patients = len(self.patients)
        espacement = max(1, self.nb_jours_max // nb_patients)
        
        for idx, patient in enumerate(self.patients):
            jour_initial = (idx * espacement) % self.nb_jours_max
            op = Operation(
                id_op=patient.id,
                duree_op=patient.duree_op,
                duree_rum=patient.duree_sejour_predite,
                spe_rss=[patient.specialite]
            )
            op.jour = jour_initial
            operations.append(op)
        
        solution = Solution(operations, self.config.dict())
        self._affecter_ressources(solution)
        return solution
    
    def _affecter_ressources(self, solution: Solution):
        """Identique à AlgorithmeGenetiqueV2"""
        for op in solution.operations:
            if op.jour is None or op.jour >= self.nb_jours_max:
                op.jour = random.randint(0, min(30, self.nb_jours_max - 1))
            op.medecin = None
            op.salle = None
        
        operations_triees = sorted(solution.operations, key=lambda x: x.jour or 0)
        occupation_medecins = defaultdict(lambda: defaultdict(float))
        occupation_salles = defaultdict(lambda: defaultdict(float))
        lits_occupes = defaultdict(int)
        
        for op in operations_triees:
            planifie = False
            specialite = op.spe_rss[0] if op.spe_rss else "Autre"
            nb_medecins = self.medecins_par_spe.get(specialite, 1)
            jour_prefere = op.jour or 0
            
            for rayon in [7, 30, self.nb_jours_max]:
                debut = max(0, jour_prefere - rayon)
                fin = min(self.nb_jours_max, jour_prefere + rayon)
                jours_a_tester = list(range(debut, fin))
                random.shuffle(jours_a_tester)
                
                for jour_test in jours_a_tester:
                    if self._est_periode_reduite(jour_test) and rayon < 30:
                        continue
                    
                    periode_reduite = self._est_periode_reduite(jour_test)
                    capacite = self.capacite_weekend if periode_reduite else 1.0
                    t_max_salle_jour = self.t_max_salle * capacite
                    t_max_medecin_jour = self.t_max_medecin * capacite
                    
                    try:
                        duree_rum_jours = max(1, int(float(op.duree_rum)))
                    except:
                        duree_rum_jours = 3
                    
                    lits_requis = duree_rum_jours + 1
                    
                    if lits_occupes[jour_test] + lits_requis > self.nb_lits:
                        continue
                    
                    medecin_trouve = None
                    for m in range(nb_medecins):
                        if occupation_medecins[jour_test][m] + op.duree_op <= t_max_medecin_jour:
                            medecin_trouve = m
                            break
                    
                    if medecin_trouve is None:
                        continue
                    
                    salle_trouvee = None
                    if specialite in ["Neurochirurgie", "Chirurgie orthopédique et traumatologique"]:
                        salle_test = self.nb_salles - 1
                        if occupation_salles[jour_test][salle_test] + op.duree_op <= t_max_salle_jour:
                            salle_trouvee = salle_test
                    else:
                        for s in range(self.nb_salles - 1):
                            if occupation_salles[jour_test][s] + op.duree_op <= t_max_salle_jour:
                                salle_trouvee = s
                                break
                    
                    if salle_trouvee is not None:
                        op.jour = jour_test
                        op.medecin = medecin_trouve
                        op.salle = salle_trouvee
                        occupation_medecins[jour_test][medecin_trouve] += op.duree_op
                        occupation_salles[jour_test][salle_trouvee] += op.duree_op
                        
                        for d in range(lits_requis):
                            if jour_test + d < self.nb_jours_max:
                                lits_occupes[jour_test + d] += 1
                        
                        planifie = True
                        break
                
                if planifie:
                    break
    
    def _calculer_cout(self, solution: Solution) -> float:
        """Identique à AlgorithmeGenetiqueV2"""
        nb_non_planifies = sum(1 for op in solution.operations if op.jour is None)
        
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                operations_par_jour[op.jour] += 1
                for d in range(duree_rum):
                    if op.jour + d < self.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations))
        else:
            rmsd = 0
        
        tv = 0
        lits_arr = [lits_par_jour.get(j, 0) for j in range(self.nb_jours_max)]
        for i in range(1, len(lits_arr)):
            tv += abs(lits_arr[i] - lits_arr[i-1])
        
        if lits_par_jour:
            dernier_jour = max(k for k, v in lits_par_jour.items() if v > 0)
            penalite_dernier_jour = lits_par_jour[dernier_jour]
        else:
            penalite_dernier_jour = 0
        
        nb_ops = list(operations_par_jour.values())
        if nb_ops:
            max_ops_jour = max(nb_ops)
            penalite_concentration = max_ops_jour
        else:
            penalite_concentration = 0
        
        max_TV = self.nb_jours_max * self.nb_salles
        max_RMSD = self.nb_lits
        max_lits_last = self.nb_lits
        max_non_affectees = len(solution.operations)
        
        cout_total = (
            (65 / max(max_TV, 1)) * tv +
            (35 / max(max_RMSD, 1)) * rmsd +
            (20 / max(max_lits_last, 1)) * penalite_dernier_jour +
            (150 / max(max_non_affectees, 1)) * nb_non_planifies +
            (10 / max(max_ops_jour if nb_ops else 1, 1)) * penalite_concentration
        )
        
        solution.cout = cout_total
        return cout_total
    
    def _generer_voisin(self, solution: Solution) -> Solution:
        """Génère voisin par permutation/décalage"""
        voisin = solution.copy()
        
        # Permuter 2 opérations
        if len(voisin.operations) >= 2:
            i, j = random.sample(range(len(voisin.operations)), 2)
            op1 = voisin.operations[i]
            op2 = voisin.operations[j]
            
            if op1.jour is not None and op2.jour is not None:
                op1.jour, op2.jour = op2.jour, op1.jour
        
        # Décaler quelques opérations
        for op in random.sample(voisin.operations, min(5, len(voisin.operations))):
            if op.jour is not None:
                decalage = random.randint(-7, 7)
                op.jour = max(0, min(self.nb_jours_max - 1, op.jour + decalage))
        
        self._affecter_ressources(voisin)
        return voisin
    
    def optimiser(self) -> Solution:
        """Exécute le recuit simulé"""
        solution_courante = self._generer_solution_initiale()
        self._calculer_cout(solution_courante)
        meilleure_solution = solution_courante.copy()
        
        temperature = self.params.t_init
        iteration = 0
        
        while temperature > self.params.t_min and iteration < self.params.max_iter * 100:
            voisin = self._generer_voisin(solution_courante)
            self._calculer_cout(voisin)
            
            delta_cout = voisin.cout - solution_courante.cout
            
            if delta_cout < 0 or random.random() < math.exp(-delta_cout / temperature):
                solution_courante = voisin
                
                if solution_courante.cout < meilleure_solution.cout:
                    meilleure_solution = solution_courante.copy()
            
            temperature *= self.params.alpha
            iteration += 1
        
        return meilleure_solution

# ============================================================================
# ENDPOINTS API
# ============================================================================

@app.get("/")
def root():
    return {
        "message": "API Optimisation Planning Hospitalier V3.0",
        "version": "3.0",
        "algorithms": ["genetic_v2", "annealing_v2"],
        "endpoints": ["/health", "/optimize"]
    }

@app.get("/health")
def health_check():
    return {
        "status": "healthy",
        "model_loaded": classifier is not None,
        "ccam_codes": len(CCAM_TO_SPE),
        "actes_autorises": len(LISTE_ACTES_AUTORISES),
        "vacances_scolaires": len(VACANCES_SCOLAIRES)
    }

@app.post("/optimize")
async def optimize_planning(request: OptimizationRequest):
    try:
        print(f"🚀 Début optimisation : {request.nb_patients} patients")
        
        # 1. Générer patients intelligemment
        df_patients = generer_patients_intelligents(request.nb_patients)
        print(f"✅ Patients générés: {len(df_patients)}")
        
        # 2. Prédire durées de séjour (ML)
        df_patients = predire_duree_sejour(df_patients)
        print(f"✅ Durées séjour prédites")
        
        # 3. Créer objets Patient
        patients = []
        for idx, row in df_patients.iterrows():
            specialite = CCAM_TO_SPE.get(row["acte_ccam"], "Chirurgie digestive")
            
            # Trouver durée opération selon spécialité
            duree_op = 120  # Défaut
            for m in request.hospital_config.medecins:
                if m["specialite"] == specialite:
                    duree_op = m["duree_moyenne"]
                    break
            
            patient = Patient(
                id=idx,
                age=int(row["age"]),
                sexe=int(row["sexe"]),
                ccam=row["acte_ccam"],
                dp=row["dp"],
                duree_sejour_predite=float(row["duree_sejour_predite"]),
                duree_op=float(duree_op),
                specialite=specialite
            )
            patients.append(patient)
        
        print(f"✅ {len(patients)} objets Patient créés")
        
        # 4. Lancer algorithme d'optimisation
        print(f"🧬 Lancement algorithme: {request.algo_params.algo_type}")
        
        if request.algo_params.algo_type == "genetic":
            algo = AlgorithmeGenetiqueV2(patients, request.hospital_config, request.algo_params)
        elif request.algo_params.algo_type == "annealing":
            algo = RecuitSimuleV2(patients, request.hospital_config, request.algo_params)
        else:
            # Par défaut, utiliser génétique
            algo = AlgorithmeGenetiqueV2(patients, request.hospital_config, request.algo_params)
        
        solution = algo.optimiser()
        print(f"✅ Optimisation terminée - Coût: {solution.cout:.2f}")
        
        # 5. Formater résultats
        lits_par_jour = defaultdict(int)
        operations_par_jour = defaultdict(int)
        operations_par_specialite = defaultdict(int)
        
        for op in solution.operations:
            if op.jour is not None:
                operations_par_jour[op.jour] += 1
                
                patient = next(p for p in patients if p.id == op.id_op)
                operations_par_specialite[patient.specialite] += 1
                
                try:
                    duree_rum = max(1, int(float(op.duree_rum))) + 1
                except:
                    duree_rum = 3
                
                for d in range(duree_rum):
                    if op.jour + d < algo.nb_jours_max:
                        lits_par_jour[op.jour + d] += 1
        
        # Planning détaillé
        planning = []
        date_debut = datetime.strptime(request.hospital_config.date_debut, "%Y-%m-%d")
        
        for op in solution.operations:
            if op.jour is not None:
                patient = next(p for p in patients if p.id == op.id_op)
                date_operation = date_debut + timedelta(days=op.jour)
                
                planning.append({
                    "patient_id": op.id_op,
                    "age": patient.age,
                    "sexe": patient.sexe,
                    "ccam": patient.ccam,
                    "dp": patient.dp,
                    "specialite": patient.specialite,
                    "date_operation": date_operation.strftime("%Y-%m-%d"),
                    "jour": op.jour,
                    "salle": op.salle if op.salle is not None else 0,
                    "medecin": op.medecin if op.medecin is not None else 0,
                    "duree_op": op.duree_op,
                    "duree_sejour": op.duree_rum,
                    "date_souhaitee": 0,
                    "ecart_jours": 0,
                    "est_weekend": algo._est_periode_reduite(op.jour),
                })
        
        # Trier par date
        planning = sorted(planning, key=lambda x: x["jour"])
        
        # Occupation lits par jour
        occupation_lits = []
        for jour in sorted(lits_par_jour.keys()):
            date = date_debut + timedelta(days=jour)
            occupation_lits.append({
                "jour": jour,
                "date": date.strftime("%Y-%m-%d"),
                "nb_lits": lits_par_jour[jour],
                "est_weekend": algo._est_periode_reduite(jour)
            })
        
        # Opérations par jour
        operations_jour = []
        for jour in sorted(operations_par_jour.keys()):
            date = date_debut + timedelta(days=jour)
            operations_jour.append({
                "jour": jour,
                "date": date.strftime("%Y-%m-%d"),
                "nb_operations": operations_par_jour[jour],
                "est_weekend": algo._est_periode_reduite(jour)
            })
        
        # Opérations par spécialité
        specialites = [
            {"specialite": spe, "nb_operations": nb}
            for spe, nb in operations_par_specialite.items()
        ]
        
        # Calcul RMSD
        occupations = list(lits_par_jour.values())
        if occupations:
            moyenne = sum(occupations) / len(occupations)
            rmsd = float(np.sqrt(sum((x - moyenne)**2 for x in occupations) / len(occupations)))
        else:
            rmsd = 0.0
        
        # Statistiques supplémentaires
        nb_planifies = len([op for op in solution.operations if op.jour is not None])
        taux_planification = (nb_planifies / len(patients)) * 100 if patients else 0
        
        # Calcul variation totale
        lits_arr = [lits_par_jour.get(j, 0) for j in range(algo.nb_jours_max)]
        tv = sum(abs(lits_arr[i] - lits_arr[i-1]) for i in range(1, len(lits_arr)))
        
        print(f"✅ Résultats: {nb_planifies}/{len(patients)} patients planifiés ({taux_planification:.1f}%)")
        
        return {
            "success": True,
            "algorithm": request.algo_params.algo_type,
            "nb_patients": len(patients),
            "nb_planifies": nb_planifies,
            "taux_planification": round(taux_planification, 2),
            "cout_total": float(solution.cout),
            "rmsd_lits": rmsd,
            "variation_totale": float(tv),
            "planning": planning,
            "occupation_lits": occupation_lits,
            "operations_par_jour": operations_jour,
            "operations_par_specialite": specialites,
            "statistiques": {
                "nb_jours_utilises": len(operations_par_jour),
                "occupation_moyenne_lits": round(moyenne, 2) if occupations else 0,
                "occupation_max_lits": max(occupations) if occupations else 0,
                "nb_operations_weekend": sum(1 for p in planning if p["est_weekend"]),
                "premier_jour": min(operations_par_jour.keys()) if operations_par_jour else 0,
                "dernier_jour": max(operations_par_jour.keys()) if operations_par_jour else 0
            }
        }
        
    except Exception as e:
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Erreur optimisation: {str(e)}")

# ============================================================================
# LANCEMENT SERVEUR
# ============================================================================

if __name__ == "__main__":
    import uvicorn
    port = int(os.environ.get("PORT", 8000))
    
    # Configuration optimisée pour Render
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=port,
        timeout_keep_alive=300,  # 5 minutes timeout
        timeout_notify=300,
        log_level="info"
    )

